!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACQUIRE	Mutex.h	/^  explicit MutexLockGuard(MutexLock& mutex) ACQUIRE(mutex)$/;"	f	class:muduo::MutexLockGuard
ACQUIRE	Mutex.h	49;"	d
ACQUIRED_AFTER	Mutex.h	40;"	d
ACQUIRED_BEFORE	Mutex.h	37;"	d
ACQUIRE_SHARED	Mutex.h	52;"	d
ADDRESS_SANITIZE	Makefile	/^ADDRESS_SANITIZE = -fsanitize=address -fno-omit-frame-pointer -fsanitize=object-size -fsanitize=float-divide-by-zero -fsanitize=bounds -static-libasan -static-libubsan$/;"	m
ASAN_FIR_DEBUG_OPT	Makefile	/^ASAN_FIR_DEBUG_OPT = -fno-omit-frame-pointer$/;"	m
ASSERT_CAPABILITY	Mutex.h	70;"	d
ASSERT_SHARED_CAPABILITY	Mutex.h	73;"	d
Acceptor	Acceptor.cc	/^Acceptor::Acceptor(EventLoop* loop, const InetAddress& listenAddr, bool reuseport)$/;"	f	class:Acceptor
Acceptor	Acceptor.h	/^		class Acceptor : noncopyable$/;"	c	namespace:muduo::net
ActiveTimer	TimerQueue.h	/^  typedef std::pair<Timer*, int64_t> ActiveTimer;$/;"	t	class:muduo::net::TimerQueue
ActiveTimerSet	TimerQueue.h	/^  typedef std::set<ActiveTimer> ActiveTimerSet;$/;"	t	class:muduo::net::TimerQueue
AppendFile	FileUtil.cc	/^FileUtil::AppendFile::AppendFile(StringArg filename)$/;"	f	class:FileUtil::AppendFile
AppendFile	FileUtil.h	/^class AppendFile : noncopyable$/;"	c	namespace:muduo::FileUtil
AsyncLogging	AsyncLogging.cc	/^AsyncLogging::AsyncLogging(const string& basename,$/;"	f	class:AsyncLogging
AsyncLogging	AsyncLogging.h	/^class AsyncLogging : noncopyable$/;"	c	namespace:muduo
AtomicInt32	Atomic.h	/^typedef detail::AtomicIntegerT<int32_t> AtomicInt32;$/;"	t	namespace:muduo
AtomicInt64	Atomic.h	/^typedef detail::AtomicIntegerT<int64_t> AtomicInt64;$/;"	t	namespace:muduo
AtomicIntegerT	Atomic.h	/^  AtomicIntegerT()$/;"	f	class:muduo::detail::AtomicIntegerT
AtomicIntegerT	Atomic.h	/^class AtomicIntegerT : noncopyable$/;"	c	namespace:muduo::detail
BUILD_DIR	Makefile	/^BUILD_DIR=$(PWD)$/;"	m
BUILD_PATH	Makefile	/^BUILD_PATH=$(BUILD_DIR)\/.obj\/release$/;"	m
BlockingQueue	BlockingQueue.h	/^  BlockingQueue()$/;"	f	class:muduo::BlockingQueue
BlockingQueue	BlockingQueue.h	/^class BlockingQueue : noncopyable$/;"	c	namespace:muduo
BoundedBlockingQueue	BoundedBlockingQueue.h	/^  explicit BoundedBlockingQueue(int maxSize)$/;"	f	class:muduo::BoundedBlockingQueue
BoundedBlockingQueue	BoundedBlockingQueue.h	/^class BoundedBlockingQueue : noncopyable$/;"	c	namespace:muduo
Buffer	AsyncLogging.h	/^  typedef muduo::detail::FixedBuffer<muduo::detail::kLargeBuffer> Buffer;$/;"	t	class:muduo::AsyncLogging
Buffer	Buffer.h	/^				explicit Buffer(size_t initialSize = kInitialSize)$/;"	f	class:muduo::net::Buffer
Buffer	Buffer.h	/^		class Buffer : public muduo::copyable$/;"	c	namespace:muduo::net
Buffer	LogStream.h	/^		typedef detail::FixedBuffer<detail::kSmallBuffer> Buffer;$/;"	t	class:muduo::LogStream
BufferPtr	AsyncLogging.h	/^  typedef BufferVector::value_type BufferPtr;$/;"	t	class:muduo::AsyncLogging
BufferVector	AsyncLogging.h	/^  typedef std::vector<std::unique_ptr<Buffer>> BufferVector;$/;"	t	class:muduo::AsyncLogging
CAPABILITY	Mutex.h	25;"	d
CHECK_NOTNULL	Logging.h	143;"	d
CXX	Makefile	/^CXX = \/usr\/bin\/myg++$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS = $(FIR_COMPILE_OPT) $(FIR_RELEASE_OPT)$/;"	m
Channel	Channel.cc	/^Channel::Channel(EventLoop* loop, int fd__)$/;"	f	class:Channel
Channel	Channel.h	/^		class Channel : noncopyable$/;"	c	namespace:muduo::net
ChannelList	EventLoop.h	/^				typedef std::vector<Channel*> ChannelList;$/;"	t	class:muduo::net::EventLoop
ChannelList	Poller.h	/^  typedef std::vector<Channel*> ChannelList;$/;"	t	class:muduo::net::Poller
ChannelMap	Poller.h	/^  typedef std::map<int, Channel*> ChannelMap;$/;"	t	class:muduo::net::Poller
CheckNotNull	Logging.h	/^		T* CheckNotNull(Logger::SourceFile file, int line, const char *names, T* ptr)$/;"	f	namespace:muduo
CloseCallback	Callbacks.h	/^typedef std::function<void (const TcpConnectionPtr&)> CloseCallback;$/;"	t	namespace:muduo::net
Comp	TimeZone.cc	/^  Comp(bool gmt)$/;"	f	struct:muduo::detail::Comp
Comp	TimeZone.cc	/^struct Comp$/;"	s	namespace:muduo::detail
Condition	Condition.h	/^  explicit Condition(MutexLock& mutex)$/;"	f	class:muduo::Condition
Condition	Condition.h	/^class Condition : noncopyable$/;"	c	namespace:muduo
ConnectionCallback	Callbacks.h	/^typedef std::function<void (const TcpConnectionPtr&)> ConnectionCallback;$/;"	t	namespace:muduo::net
ConnectionMap	TcpServer.h	/^				typedef std::map<string, TcpConnectionPtr> ConnectionMap;$/;"	t	class:muduo::net::TcpServer
Connector	Connector.cc	/^Connector::Connector(EventLoop* loop, const InetAddress& serverAddr)$/;"	f	class:Connector
Connector	Connector.h	/^		class Connector : noncopyable,$/;"	c	namespace:muduo::net
ConnectorPtr	TcpClient.h	/^		typedef std::shared_ptr<Connector> ConnectorPtr;$/;"	t	namespace:muduo::net
CopyToString	StringPiece.h	/^			void CopyToString(string* target) const {$/;"	f	class:muduo::StringPiece
CountDownLatch	CountDownLatch.cc	/^CountDownLatch::CountDownLatch(int count)$/;"	f	class:CountDownLatch
CountDownLatch	CountDownLatch.h	/^class CountDownLatch : noncopyable$/;"	c	namespace:muduo
CpuTime	ProcessInfo.h	/^    CpuTime() : userSeconds(0.0), systemSeconds(0.0) { }$/;"	f	struct:muduo::ProcessInfo::CpuTime
CpuTime	ProcessInfo.h	/^  struct CpuTime$/;"	s	namespace:muduo::ProcessInfo
CurrentThread	CurrentThread.cc	/^namespace CurrentThread$/;"	n	namespace:muduo
CurrentThread	CurrentThread.h	/^	namespace CurrentThread$/;"	n	namespace:muduo
DEBUG	Logging.h	/^				DEBUG,$/;"	e	enum:muduo::Logger::LogLevel
DEBUG_BUILD_PATH	Makefile	/^DEBUG_BUILD_PATH=$(BUILD_DIR)\/.obj\/debug$/;"	m
DEBUG_CXXFLAGS	Makefile	/^DEBUG_CXXFLAGS = $(FIR_COMPILE_OPT)$/;"	m
DEBUG_DEPS	Makefile	/^DEBUG_DEPS = $(DEBUG_OBJS:$(DEBUG_BUILD_PATH)\/%.o=$(DEBUG_BUILD_PATH)\/.%.d)$/;"	m
DEBUG_OBJS	Makefile	/^DEBUG_OBJS := $(patsubst %.cc, $(DEBUG_BUILD_PATH)\/%.o, $(wildcard *.cc))$/;"	m
DEBUG_TARGET	Makefile	/^DEBUG_TARGET = $(DEBUG_BUILD_PATH)\/lib$(TARGET_NAME)_D.a$/;"	m
DEPS	Makefile	/^DEPS = $(OBJS:$(BUILD_PATH)\/%.o=$(BUILD_PATH)\/.%.d)$/;"	m
Data	TimeZone.cc	/^struct TimeZone::Data$/;"	s	class:TimeZone
Date	Date.cc	/^Date::Date(const struct tm& t)$/;"	f	class:Date
Date	Date.cc	/^Date::Date(int y, int m, int d)$/;"	f	class:Date
Date	Date.h	/^  Date()$/;"	f	class:muduo::Date
Date	Date.h	/^  explicit Date(int julianDayNum)$/;"	f	class:muduo::Date
Date	Date.h	/^class Date : public muduo::copyable$/;"	c	namespace:muduo
Deleter	ThreadLocalSingleton.h	/^    Deleter()$/;"	f	class:muduo::ThreadLocalSingleton::Deleter
Deleter	ThreadLocalSingleton.h	/^  class Deleter$/;"	c	class:muduo::ThreadLocalSingleton
EPollPoller	EPollPoller.cc	/^EPollPoller::EPollPoller(EventLoop* loop)$/;"	f	class:EPollPoller
EPollPoller	EPollPoller.h	/^		class EPollPoller : public Poller$/;"	c	namespace:muduo::net
ERROR	Logging.h	/^				ERROR,$/;"	e	enum:muduo::Logger::LogLevel
EXCLUDES	Mutex.h	67;"	d
Entry	TimerQueue.h	/^  typedef std::pair<Timestamp, Timer*> Entry;$/;"	t	class:muduo::net::TimerQueue
EventCallback	Channel.h	/^				typedef std::function<void()> EventCallback;$/;"	t	class:muduo::net::Channel
EventList	EPollPoller.h	/^				typedef std::vector<struct epoll_event> EventList;$/;"	t	class:muduo::net::EPollPoller
EventLoop	EventLoop.cc	/^EventLoop::EventLoop()$/;"	f	class:EventLoop
EventLoop	EventLoop.h	/^		class EventLoop : noncopyable$/;"	c	namespace:muduo::net
EventLoopThread	EventLoopThread.cc	/^EventLoopThread::EventLoopThread(const ThreadInitCallback& cb,$/;"	f	class:EventLoopThread
EventLoopThread	EventLoopThread.h	/^		class EventLoopThread : noncopyable$/;"	c	namespace:muduo::net
EventLoopThreadPool	EventLoopThreadPool.cc	/^EventLoopThreadPool::EventLoopThreadPool(EventLoop* baseLoop, const string& nameArg)$/;"	f	class:EventLoopThreadPool
EventLoopThreadPool	EventLoopThreadPool.h	/^class EventLoopThreadPool : noncopyable$/;"	c	namespace:muduo::net
Exception	Exception.cc	/^Exception::Exception(string msg)$/;"	f	class:muduo::Exception
Exception	Exception.h	/^class Exception : public std::exception$/;"	c	namespace:muduo
FATAL	Logging.h	/^				FATAL,$/;"	e	enum:muduo::Logger::LogLevel
FIR_COMPILE_OPT	Makefile	/^FIR_COMPILE_OPT = -std=gnu++11 -g -g3 -fPIC -Wno-stringop-truncation -fno-strict-aliasing -Werror -Wall -D_GNU_SOURCE -D_REENTRANT$/;"	m
FIR_RELEASE_OPT	Makefile	/^FIR_RELEASE_OPT = -O2 -fno-omit-frame-pointer$/;"	m
File	TimeZone.cc	/^  File(const char* file)$/;"	f	class:muduo::detail::File
File	TimeZone.cc	/^class File : noncopyable$/;"	c	namespace:muduo::detail
FileUtil	FileUtil.h	/^namespace FileUtil$/;"	n	namespace:muduo
FileUtil	LogFile.h	/^namespace FileUtil$/;"	n	namespace:muduo
FixedBuffer	LogStream.h	/^				FixedBuffer()$/;"	f	class:muduo::detail::FixedBuffer
FixedBuffer	LogStream.h	/^			class FixedBuffer : noncopyable$/;"	c	namespace:muduo::detail
FlushFunc	Logging.h	/^			typedef void (*FlushFunc)();$/;"	t	class:muduo::Logger
Fmt	LogStream.cc	/^Fmt::Fmt(const char* fmt, T val)$/;"	f	class:Fmt
Fmt	LogStream.h	/^	class Fmt \/\/ : noncopyable$/;"	c	namespace:muduo
Functor	EventLoop.h	/^				typedef std::function<void()> Functor;$/;"	t	class:muduo::net::EventLoop
GUARDED_BY	Mutex.h	31;"	d
GzipFile	GzipFile.h	/^  explicit GzipFile(gzFile file)$/;"	f	class:muduo::GzipFile
GzipFile	GzipFile.h	/^class GzipFile : noncopyable$/;"	c	namespace:muduo
HighWaterMarkCallback	Callbacks.h	/^typedef std::function<void (const TcpConnectionPtr&, size_t)> HighWaterMarkCallback;$/;"	t	namespace:muduo::net
INCLUDE_PATH	Makefile	/^INCLUDE_PATH ?= include\/$(TARGET_NAME)$/;"	m
INC_PATH	Makefile	/^INC_PATH := \\$/;"	m
INFO	Logging.h	/^				INFO,$/;"	e	enum:muduo::Logger::LogLevel
INSTALL	Makefile	/^INSTALL ?= cp -a$/;"	m
INSTALL_INCLUDE_PATH	Makefile	/^INSTALL_INCLUDE_PATH=$(PREFIX)\/$(INCLUDE_PATH)$/;"	m
INSTALL_LIBRARY_PATH	Makefile	/^INSTALL_LIBRARY_PATH = $(PREFIX)\/lib$/;"	m
IgnoreSigPipe	EventLoop.cc	/^			IgnoreSigPipe()$/;"	f	class:__anon2::IgnoreSigPipe
IgnoreSigPipe	EventLoop.cc	/^	class IgnoreSigPipe$/;"	c	namespace:__anon2
Impl	Logging.cc	/^Logger::Impl::Impl(LogLevel level, int savedErrno, const SourceFile& file, int line)$/;"	f	class:Logger::Impl
Impl	Logging.h	/^			class Impl$/;"	c	class:muduo::Logger
InetAddress	InetAddress.cc	/^InetAddress::InetAddress(StringArg ip, uint16_t port, bool ipv6)$/;"	f	class:InetAddress
InetAddress	InetAddress.cc	/^InetAddress::InetAddress(uint16_t port, bool loopbackOnly, bool ipv6)$/;"	f	class:InetAddress
InetAddress	InetAddress.h	/^				explicit InetAddress(const struct sockaddr_in& addr)$/;"	f	class:muduo::net::InetAddress
InetAddress	InetAddress.h	/^				explicit InetAddress(const struct sockaddr_in6& addr)$/;"	f	class:muduo::net::InetAddress
InetAddress	InetAddress.h	/^		class InetAddress : public muduo::copyable$/;"	c	namespace:muduo::net
LOG_DEBUG	Logging.h	126;"	d
LOG_ERROR	Logging.h	131;"	d
LOG_FATAL	Logging.h	132;"	d
LOG_INFO	Logging.h	128;"	d
LOG_SYSERR	Logging.h	133;"	d
LOG_SYSFATAL	Logging.h	134;"	d
LOG_TRACE	Logging.h	124;"	d
LOG_WARN	Logging.h	130;"	d
Localtime	TimeZone.cc	/^  Localtime(time_t offset, bool dst, int arrb)$/;"	f	struct:muduo::detail::Localtime
Localtime	TimeZone.cc	/^struct Localtime$/;"	s	namespace:muduo::detail
LogFile	LogFile.cc	/^LogFile::LogFile(const string& basename,$/;"	f	class:LogFile
LogFile	LogFile.h	/^class LogFile : noncopyable$/;"	c	namespace:muduo
LogLevel	Logging.h	/^					typedef Logger::LogLevel LogLevel;$/;"	t	class:muduo::Logger::Impl
LogLevel	Logging.h	/^			enum LogLevel$/;"	g	class:muduo::Logger
LogLevelName	Logging.cc	/^	const char* LogLevelName[Logger::NUM_LOG_LEVELS] =$/;"	m	namespace:muduo
LogStream	LogStream.h	/^	class LogStream : noncopyable$/;"	c	namespace:muduo
Logger	Logging.cc	/^Logger::Logger(SourceFile file, int line)$/;"	f	class:Logger
Logger	Logging.cc	/^Logger::Logger(SourceFile file, int line, LogLevel level)$/;"	f	class:Logger
Logger	Logging.cc	/^Logger::Logger(SourceFile file, int line, LogLevel level, const char* func)$/;"	f	class:Logger
Logger	Logging.cc	/^Logger::Logger(SourceFile file, int line, bool toAbort)$/;"	f	class:Logger
Logger	Logging.h	/^	class Logger$/;"	c	namespace:muduo
MCHECK	Mutex.h	96;"	d
MUDUO_BASE_ASYNCLOGGING_H	AsyncLogging.h	7;"	d
MUDUO_BASE_ATOMIC_H	Atomic.h	7;"	d
MUDUO_BASE_BLOCKINGQUEUE_H	BlockingQueue.h	7;"	d
MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H	BoundedBlockingQueue.h	7;"	d
MUDUO_BASE_CONDITION_H	Condition.h	7;"	d
MUDUO_BASE_COPYABLE_H	copyable.h	2;"	d
MUDUO_BASE_COUNTDOWNLATCH_H	CountDownLatch.h	7;"	d
MUDUO_BASE_CURRENTTHREAD_H	CurrentThread.h	7;"	d
MUDUO_BASE_DATE_H	Date.h	7;"	d
MUDUO_BASE_EXCEPTION_H	Exception.h	7;"	d
MUDUO_BASE_FILEUTIL_H	FileUtil.h	9;"	d
MUDUO_BASE_LOGFILE_H	LogFile.h	7;"	d
MUDUO_BASE_LOGGING_H	Logging.h	7;"	d
MUDUO_BASE_LOGSTREAM_H	LogStream.h	7;"	d
MUDUO_BASE_MUTEX_H	Mutex.h	7;"	d
MUDUO_BASE_NONCOPYABLE_H	noncopyable.h	2;"	d
MUDUO_BASE_PROCESSINFO_H	ProcessInfo.h	9;"	d
MUDUO_BASE_SINGLETON_H	Singleton.h	7;"	d
MUDUO_BASE_STRINGPIECE_H	StringPiece.h	41;"	d
MUDUO_BASE_THREADLOCALSINGLETON_H	ThreadLocalSingleton.h	7;"	d
MUDUO_BASE_THREADLOCAL_H	ThreadLocal.h	7;"	d
MUDUO_BASE_THREADPOOL_H	ThreadPool.h	7;"	d
MUDUO_BASE_THREAD_H	Thread.h	7;"	d
MUDUO_BASE_TIMESTAMP_H	Timestamp.h	7;"	d
MUDUO_BASE_TIMEZONE_H	TimeZone.h	7;"	d
MUDUO_BASE_TYPES_H	Types.h	2;"	d
MUDUO_BASE_WEAKCALLBACK_H	WeakCallback.h	7;"	d
MUDUO_NET_ACCEPTOR_H	Acceptor.h	12;"	d
MUDUO_NET_BUFFER_H	Buffer.h	12;"	d
MUDUO_NET_CALLBACKS_H	Callbacks.h	12;"	d
MUDUO_NET_CHANNEL_H	Channel.h	12;"	d
MUDUO_NET_CONNECTOR_H	Connector.h	12;"	d
MUDUO_NET_ENDIAN_H	Endian.h	12;"	d
MUDUO_NET_EVENTLOOPTHREADPOOL_H	EventLoopThreadPool.h	12;"	d
MUDUO_NET_EVENTLOOPTHREAD_H	EventLoopThread.h	12;"	d
MUDUO_NET_EVENTLOOP_H	EventLoop.h	12;"	d
MUDUO_NET_INETADDRESS_H	InetAddress.h	12;"	d
MUDUO_NET_POLLER_EPOLLPOLLER_H	EPollPoller.h	12;"	d
MUDUO_NET_POLLER_H	Poller.h	12;"	d
MUDUO_NET_POLLER_POLLPOLLER_H	PollPoller.h	12;"	d
MUDUO_NET_SOCKETSOPS_H	SocketsOps.h	12;"	d
MUDUO_NET_SOCKET_H	Socket.h	12;"	d
MUDUO_NET_TCPCLIENT_H	TcpClient.h	12;"	d
MUDUO_NET_TCPCONNECTION_H	TcpConnection.h	12;"	d
MUDUO_NET_TCPSERVER_H	TcpServer.h	12;"	d
MUDUO_NET_TIMERID_H	TimerId.h	12;"	d
MUDUO_NET_TIMERQUEUE_H	TimerQueue.h	12;"	d
MUDUO_NET_TIMER_H	Timer.h	12;"	d
MessageCallback	Callbacks.h	/^                            Timestamp)> MessageCallback;$/;"	t	namespace:muduo::net
MutexLockGuard	Mutex.h	/^class SCOPED_CAPABILITY MutexLockGuard : noncopyable$/;"	c	namespace:muduo
MutexLockGuard	Mutex.h	231;"	d
NO_THREAD_SAFETY_ANALYSIS	Mutex.h	79;"	d
NUM_LOG_LEVELS	Logging.h	/^				NUM_LOG_LEVELS,$/;"	e	enum:muduo::Logger::LogLevel
NewConnectionCallback	Acceptor.h	/^				typedef std::function<void (int sockfd, const InetAddress&)> NewConnectionCallback;$/;"	t	class:muduo::net::Acceptor
NewConnectionCallback	Connector.h	/^				typedef std::function<void (int sockfd)> NewConnectionCallback;$/;"	t	class:muduo::net::Connector
OBJS	Makefile	/^OBJS := $(patsubst %.cc, $(BUILD_PATH)\/%.o, $(wildcard *.cc))$/;"	m
Option	TcpServer.h	/^				enum Option$/;"	g	class:muduo::net::TcpServer
OutputFunc	Logging.h	/^			typedef void (*OutputFunc)(const char* msg, int len);$/;"	t	class:muduo::Logger
PREFIX	Makefile	/^PREFIX ?= ..\/3rd$/;"	m
PT_GUARDED_BY	Mutex.h	34;"	d
PollFdList	PollPoller.h	/^  typedef std::vector<struct pollfd> PollFdList;$/;"	t	class:muduo::net::PollPoller
PollPoller	PollPoller.cc	/^PollPoller::PollPoller(EventLoop* loop)$/;"	f	class:PollPoller
PollPoller	PollPoller.h	/^class PollPoller : public Poller$/;"	c	namespace:muduo::net
Poller	Poller.cc	/^Poller::Poller(EventLoop* loop)$/;"	f	class:Poller
Poller	Poller.h	/^class Poller : noncopyable$/;"	c	namespace:muduo::net
ProcessInfo	ProcessInfo.h	/^namespace ProcessInfo$/;"	n	namespace:muduo
RELEASE	Mutex.h	/^  ~MutexLockGuard() RELEASE()$/;"	f	class:muduo::MutexLockGuard
RELEASE	Mutex.h	55;"	d
RELEASE_SHARED	Mutex.h	58;"	d
REQUIRES	Mutex.h	43;"	d
REQUIRES_SHARED	Mutex.h	46;"	d
RETURN_CAPABILITY	Mutex.h	76;"	d
ReadEventCallback	Channel.h	/^				typedef std::function<void(Timestamp)> ReadEventCallback;$/;"	t	class:muduo::net::Channel
ReadSmallFile	FileUtil.cc	/^FileUtil::ReadSmallFile::ReadSmallFile(StringArg filename)$/;"	f	class:FileUtil::ReadSmallFile
ReadSmallFile	FileUtil.h	/^class ReadSmallFile : noncopyable$/;"	c	namespace:muduo::FileUtil
SA	SocketsOps.cc	/^	typedef struct sockaddr SA;$/;"	t	namespace:__anon1	typeref:struct:__anon1::sockaddr
SCOPED_CAPABILITY	Mutex.h	28;"	d
STRINGPIECE_BINARY_PREDICATE	StringPiece.h	132;"	d
STRINGPIECE_BINARY_PREDICATE	StringPiece.h	141;"	d
Singleton	Singleton.h	/^class Singleton : noncopyable$/;"	c	namespace:muduo
Socket	Socket.h	/^				explicit Socket(int sockfd)$/;"	f	class:muduo::net::Socket
Socket	Socket.h	/^		class Socket : noncopyable$/;"	c	namespace:muduo::net
SourceFile	Logging.h	/^						SourceFile(const char (&arr)[N])$/;"	f	class:muduo::Logger::SourceFile
SourceFile	Logging.h	/^					explicit SourceFile(const char* filename)$/;"	f	class:muduo::Logger::SourceFile
SourceFile	Logging.h	/^			class SourceFile$/;"	c	class:muduo::Logger
StateE	TcpConnection.h	/^				enum StateE { kDisconnected, kConnecting, kConnected, kDisconnecting };$/;"	g	class:muduo::net::TcpConnection
States	Connector.h	/^				enum States { kDisconnected, kConnecting, kConnected };$/;"	g	class:muduo::net::Connector
StringArg	StringPiece.h	/^			StringArg(const char* str)$/;"	f	class:muduo::StringArg
StringArg	StringPiece.h	/^			StringArg(const string& str)$/;"	f	class:muduo::StringArg
StringArg	StringPiece.h	/^	class StringArg \/\/ copyable$/;"	c	namespace:muduo
StringPiece	StringPiece.h	/^			StringPiece()$/;"	f	class:muduo::StringPiece
StringPiece	StringPiece.h	/^			StringPiece(const char* offset, int len)$/;"	f	class:muduo::StringPiece
StringPiece	StringPiece.h	/^			StringPiece(const char* str)$/;"	f	class:muduo::StringPiece
StringPiece	StringPiece.h	/^			StringPiece(const string& str)$/;"	f	class:muduo::StringPiece
StringPiece	StringPiece.h	/^			StringPiece(const unsigned char* str)$/;"	f	class:muduo::StringPiece
StringPiece	StringPiece.h	/^	class StringPiece {$/;"	c	namespace:muduo
T	Logging.cc	/^			T(const char* str, unsigned len)$/;"	f	class:muduo::T
T	Logging.cc	/^	class T$/;"	c	namespace:muduo
TARGET	Makefile	/^TARGET = $(BUILD_PATH)\/lib$(TARGET_NAME).a$/;"	m
TARGET_NAME	Makefile	/^TARGET_NAME=muduo$/;"	m
THREAD_ANNOTATION_ATTRIBUTE__	Mutex.h	20;"	d
THREAD_ANNOTATION_ATTRIBUTE__	Mutex.h	22;"	d
TRACE	Logging.h	/^				TRACE,$/;"	e	enum:muduo::Logger::LogLevel
TRY_ACQUIRE	Mutex.h	61;"	d
TRY_ACQUIRE_SHARED	Mutex.h	64;"	d
Task	ThreadPool.h	/^  typedef std::function<void ()> Task;$/;"	t	class:muduo::ThreadPool
TcpClient	TcpClient.cc	/^TcpClient::TcpClient(EventLoop* loop,$/;"	f	class:TcpClient
TcpClient	TcpClient.h	/^		class TcpClient : noncopyable$/;"	c	namespace:muduo::net
TcpConnection	TcpConnection.cc	/^TcpConnection::TcpConnection(EventLoop* loop,$/;"	f	class:TcpConnection
TcpConnection	TcpConnection.h	/^		class TcpConnection : noncopyable,$/;"	c	namespace:muduo::net
TcpConnectionPtr	Callbacks.h	/^typedef std::shared_ptr<TcpConnection> TcpConnectionPtr;$/;"	t	namespace:muduo::net
TcpConnectionPtr	TcpConnection.h	/^		typedef std::shared_ptr<TcpConnection> TcpConnectionPtr;$/;"	t	namespace:muduo::net
TcpServer	TcpServer.cc	/^TcpServer::TcpServer(EventLoop* loop,$/;"	f	class:TcpServer
TcpServer	TcpServer.h	/^		class TcpServer : noncopyable$/;"	c	namespace:muduo::net
Thread	Thread.cc	/^	Thread::Thread(ThreadFunc func, const string& n)$/;"	f	class:muduo::Thread
Thread	Thread.h	/^	class Thread : noncopyable$/;"	c	namespace:muduo
ThreadData	Thread.cc	/^			ThreadData(ThreadFunc func,$/;"	f	struct:muduo::detail::ThreadData
ThreadData	Thread.cc	/^		struct ThreadData$/;"	s	namespace:muduo::detail
ThreadFunc	Thread.cc	/^			typedef muduo::Thread::ThreadFunc ThreadFunc;$/;"	t	struct:muduo::detail::ThreadData
ThreadFunc	Thread.h	/^			typedef std::function<void ()> ThreadFunc;$/;"	t	class:muduo::Thread
ThreadInitCallback	EventLoopThread.h	/^				typedef std::function<void(EventLoop*)> ThreadInitCallback;$/;"	t	class:muduo::net::EventLoopThread
ThreadInitCallback	EventLoopThreadPool.h	/^  typedef std::function<void(EventLoop*)> ThreadInitCallback;$/;"	t	class:muduo::net::EventLoopThreadPool
ThreadInitCallback	TcpServer.h	/^				typedef std::function<void(EventLoop*)> ThreadInitCallback;$/;"	t	class:muduo::net::TcpServer
ThreadLocal	ThreadLocal.h	/^  ThreadLocal()$/;"	f	class:muduo::ThreadLocal
ThreadLocal	ThreadLocal.h	/^class ThreadLocal : noncopyable$/;"	c	namespace:muduo
ThreadLocalSingleton	ThreadLocalSingleton.h	/^class ThreadLocalSingleton : noncopyable$/;"	c	namespace:muduo
ThreadNameInitializer	Thread.cc	/^				ThreadNameInitializer()$/;"	f	class:muduo::detail::ThreadNameInitializer
ThreadNameInitializer	Thread.cc	/^		class ThreadNameInitializer$/;"	c	namespace:muduo::detail
ThreadPool	ThreadPool.cc	/^ThreadPool::ThreadPool(const string& nameArg)$/;"	f	class:ThreadPool
ThreadPool	ThreadPool.h	/^class ThreadPool : noncopyable$/;"	c	namespace:muduo
TimeZone	TimeZone.cc	/^TimeZone::TimeZone(const char* zonefile)$/;"	f	class:TimeZone
TimeZone	TimeZone.cc	/^TimeZone::TimeZone(int eastOfUtc, const char* name)$/;"	f	class:TimeZone
TimeZone	TimeZone.h	/^class TimeZone : public muduo::copyable$/;"	c	namespace:muduo
Timer	Timer.h	/^  Timer(TimerCallback cb, Timestamp when, double interval)$/;"	f	class:muduo::net::Timer
Timer	Timer.h	/^class Timer : noncopyable$/;"	c	namespace:muduo::net
TimerCallback	Callbacks.h	/^typedef std::function<void()> TimerCallback;$/;"	t	namespace:muduo::net
TimerId	TimerId.h	/^  TimerId()$/;"	f	class:muduo::net::TimerId
TimerId	TimerId.h	/^  TimerId(Timer* timer, int64_t seq)$/;"	f	class:muduo::net::TimerId
TimerId	TimerId.h	/^class TimerId : public muduo::copyable$/;"	c	namespace:muduo::net
TimerList	TimerQueue.h	/^  typedef std::set<Entry> TimerList;$/;"	t	class:muduo::net::TimerQueue
TimerQueue	TimerQueue.cc	/^TimerQueue::TimerQueue(EventLoop* loop)$/;"	f	class:TimerQueue
TimerQueue	TimerQueue.h	/^class TimerQueue : noncopyable$/;"	c	namespace:muduo::net
Timestamp	Timestamp.h	/^  Timestamp()$/;"	f	class:muduo::Timestamp
Timestamp	Timestamp.h	/^  explicit Timestamp(int64_t microSecondsSinceEpochArg)$/;"	f	class:muduo::Timestamp
Timestamp	Timestamp.h	/^class Timestamp : public muduo::copyable$/;"	c	namespace:muduo
Transition	TimeZone.cc	/^  Transition(time_t t, time_t l, int localIdx)$/;"	f	struct:muduo::detail::Transition
Transition	TimeZone.cc	/^struct Transition$/;"	s	namespace:muduo::detail
WARN	Logging.h	/^				WARN,$/;"	e	enum:muduo::Logger::LogLevel
WeakCallback	WeakCallback.h	/^  WeakCallback(const std::weak_ptr<CLASS>& object,$/;"	f	class:muduo::WeakCallback
WeakCallback	WeakCallback.h	/^class WeakCallback$/;"	c	namespace:muduo
WriteCompleteCallback	Callbacks.h	/^typedef std::function<void (const TcpConnectionPtr&)> WriteCompleteCallback;$/;"	t	namespace:muduo::net
YearMonthDay	Date.h	/^  struct YearMonthDay$/;"	s	class:muduo::Date
ZlibInputStream	ZlibStream.h	/^  explicit ZlibInputStream(Buffer* output)$/;"	f	class:muduo::net::ZlibInputStream
ZlibInputStream	ZlibStream.h	/^class ZlibInputStream : noncopyable$/;"	c	namespace:muduo::net
ZlibOutputStream	ZlibStream.h	/^  explicit ZlibOutputStream(Buffer* output)$/;"	f	class:muduo::net::ZlibOutputStream
ZlibOutputStream	ZlibStream.h	/^class ZlibOutputStream : noncopyable$/;"	c	namespace:muduo::net
__STDC_FORMAT_MACROS	LogStream.cc	17;"	d
__STDC_FORMAT_MACROS	Timestamp.cc	13;"	d
__STDC_LIMIT_MACROS	TimerQueue.cc	10;"	d
__type_traits	StringPiece.h	/^template<> struct __type_traits<muduo::StringPiece> {$/;"	s
abbreviation	TimeZone.cc	/^  string abbreviation;$/;"	m	struct:TimeZone::Data
abortNotInLoopThread	EventLoop.cc	/^void EventLoop::abortNotInLoopThread()$/;"	f	class:EventLoop
accept	Socket.cc	/^int Socket::accept(InetAddress* peeraddr)$/;"	f	class:Socket
accept	SocketsOps.cc	/^int sockets::accept(int sockfd, struct sockaddr_in6* addr)$/;"	f	class:sockets
acceptChannel_	Acceptor.h	/^				Channel acceptChannel_;$/;"	m	class:muduo::net::Acceptor
acceptSocket_	Acceptor.h	/^				Socket acceptSocket_;$/;"	m	class:muduo::net::Acceptor
acceptor_	TcpServer.h	/^				std::unique_ptr<Acceptor> acceptor_; \/\/ avoid revealing Acceptor$/;"	m	class:muduo::net::TcpServer
activeChannels_	EventLoop.h	/^				ChannelList activeChannels_;$/;"	m	class:muduo::net::EventLoop
activeTimers_	TimerQueue.h	/^  ActiveTimerSet activeTimers_;$/;"	m	class:muduo::net::TimerQueue
add	Atomic.h	/^  void add(T x)$/;"	f	class:muduo::detail::AtomicIntegerT
add	LogStream.h	/^				void add(size_t len) { cur_ += len; }$/;"	f	class:muduo::detail::FixedBuffer
addAndGet	Atomic.h	/^  T addAndGet(T x)$/;"	f	class:muduo::detail::AtomicIntegerT
addTime	Timestamp.h	/^inline Timestamp addTime(Timestamp timestamp, double seconds)$/;"	f	namespace:muduo
addTimer	TimerQueue.cc	/^TimerId TimerQueue::addTimer(TimerCallback cb,$/;"	f	class:TimerQueue
addTimerInLoop	TimerQueue.cc	/^void TimerQueue::addTimerInLoop(Timer* timer)$/;"	f	class:TimerQueue
addedToLoop_	Channel.h	/^				bool addedToLoop_;$/;"	m	class:muduo::net::Channel
addr6_	InetAddress.h	/^					struct sockaddr_in6 addr6_;$/;"	m	union:muduo::net::InetAddress::__anon3	typeref:struct:muduo::net::InetAddress::__anon3::sockaddr_in6
addr_	InetAddress.h	/^					struct sockaddr_in addr_;$/;"	m	union:muduo::net::InetAddress::__anon3	typeref:struct:muduo::net::InetAddress::__anon3::sockaddr_in
afterFork	Thread.cc	/^		void afterFork()$/;"	f	namespace:muduo::detail
append	AsyncLogging.cc	/^void AsyncLogging::append(const char* logline, int len)$/;"	f	class:AsyncLogging
append	Buffer.h	/^				void append(const StringPiece& str)$/;"	f	class:muduo::net::Buffer
append	Buffer.h	/^				void append(const char* \/*restrict*\/ data, size_t len)$/;"	f	class:muduo::net::Buffer
append	Buffer.h	/^				void append(const void* \/*restrict*\/ data, size_t len)$/;"	f	class:muduo::net::Buffer
append	FileUtil.cc	/^void FileUtil::AppendFile::append(const char* logline, const size_t len)$/;"	f	class:FileUtil::AppendFile
append	LogFile.cc	/^void LogFile::append(const char* logline, int len)$/;"	f	class:LogFile
append	LogStream.h	/^				void append(const char* \/*restrict*\/ buf, size_t len)$/;"	f	class:muduo::detail::FixedBuffer
append	LogStream.h	/^		void append(const char* data, int len) { buffer_.append(data, len); }$/;"	f	class:muduo::LogStream
appendInt16	Buffer.h	/^				void appendInt16(int16_t x)$/;"	f	class:muduo::net::Buffer
appendInt32	Buffer.h	/^				void appendInt32(int32_t x)$/;"	f	class:muduo::net::Buffer
appendInt64	Buffer.h	/^				void appendInt64(int64_t x)$/;"	f	class:muduo::net::Buffer
appendInt8	Buffer.h	/^				void appendInt8(int8_t x)$/;"	f	class:muduo::net::Buffer
append_unlocked	LogFile.cc	/^void LogFile::append_unlocked(const char* logline, int len)$/;"	f	class:LogFile
arrbIdx	TimeZone.cc	/^  int arrbIdx;$/;"	m	struct:muduo::detail::Localtime
as_string	StringPiece.h	/^			string as_string() const {$/;"	f	class:muduo::StringPiece
assertInLoopThread	EventLoop.h	/^				void assertInLoopThread()$/;"	f	class:muduo::net::EventLoop
assertInLoopThread	Poller.h	/^  void assertInLoopThread() const$/;"	f	class:muduo::net::Poller
avail	LogStream.h	/^				int avail() const { return static_cast<int>(end() - cur_); }$/;"	f	class:muduo::detail::FixedBuffer
baseLoop_	EventLoopThreadPool.h	/^  EventLoop* baseLoop_;$/;"	m	class:muduo::net::EventLoopThreadPool
basename_	AsyncLogging.h	/^  const string basename_;$/;"	m	class:muduo::AsyncLogging
basename_	LogFile.h	/^  const string basename_;$/;"	m	class:muduo::LogFile
basename_	Logging.h	/^					SourceFile basename_;$/;"	m	class:muduo::Logger::Impl
begin	Buffer.h	/^				char* begin()$/;"	f	class:muduo::net::Buffer
begin	Buffer.h	/^				const char* begin() const$/;"	f	class:muduo::net::Buffer
begin	StringPiece.h	/^			const char* begin() const { return ptr_; }$/;"	f	class:muduo::StringPiece
beginWrite	Buffer.h	/^				char* beginWrite()$/;"	f	class:muduo::net::Buffer
beginWrite	Buffer.h	/^				const char* beginWrite() const$/;"	f	class:muduo::net::Buffer
bindAddress	Socket.cc	/^void Socket::bindAddress(const InetAddress& addr)$/;"	f	class:Socket
bindOrDie	SocketsOps.cc	/^void sockets::bindOrDie(int sockfd, const struct sockaddr* addr)$/;"	f	class:sockets
buf_	FileUtil.h	/^  char buf_[kBufferSize];$/;"	m	class:muduo::FileUtil::ReadSmallFile
buf_	LogStream.h	/^			char buf_[32];$/;"	m	class:muduo::Fmt
buffer	FileUtil.h	/^  const char* buffer() const { return buf_; }$/;"	f	class:muduo::FileUtil::ReadSmallFile
buffer	LogStream.h	/^		const Buffer& buffer() const { return buffer_; }$/;"	f	class:muduo::LogStream
bufferSize_	ZlibStream.h	/^  int bufferSize_;$/;"	m	class:muduo::net::ZlibOutputStream
buffer_	Buffer.h	/^				std::vector<char> buffer_;$/;"	m	class:muduo::net::Buffer
buffer_	FileUtil.h	/^  char buffer_[64*1024];$/;"	m	class:muduo::FileUtil::AppendFile
buffer_	LogStream.h	/^		Buffer buffer_;$/;"	m	class:muduo::LogStream
bzero	LogStream.h	/^				void bzero() { memZero(data_, sizeof data_); }$/;"	f	class:muduo::detail::FixedBuffer
c_str	StringPiece.h	/^			const char* c_str() const { return str_; }$/;"	f	class:muduo::StringArg
cacheTid	Thread.cc	/^	void CurrentThread::cacheTid()$/;"	f	class:muduo::CurrentThread
callback_	EventLoopThread.h	/^				ThreadInitCallback callback_;$/;"	m	class:muduo::net::EventLoopThread
callback_	Timer.h	/^  const TimerCallback callback_;$/;"	m	class:muduo::net::Timer
callingExpiredTimers_	TimerQueue.h	/^  bool callingExpiredTimers_; \/* atomic *\/$/;"	m	class:muduo::net::TimerQueue
callingPendingFunctors_	EventLoop.h	/^				bool callingPendingFunctors_; \/* atomic *\/$/;"	m	class:muduo::net::EventLoop
cancel	EventLoop.cc	/^void EventLoop::cancel(TimerId timerId)$/;"	f	class:EventLoop
cancel	TimerQueue.cc	/^void TimerQueue::cancel(TimerId timerId)$/;"	f	class:TimerQueue
cancelInLoop	TimerQueue.cc	/^void TimerQueue::cancelInLoop(TimerId timerId)$/;"	f	class:TimerQueue
cancelingTimers_	TimerQueue.h	/^  ActiveTimerSet cancelingTimers_;$/;"	m	class:muduo::net::TimerQueue
capacity	BoundedBlockingQueue.h	/^  size_t capacity() const$/;"	f	class:muduo::BoundedBlockingQueue
channel_	Connector.h	/^				std::unique_ptr<Channel> channel_;$/;"	m	class:muduo::net::Connector
channel_	TcpConnection.h	/^				std::unique_ptr<Channel> channel_;$/;"	m	class:muduo::net::TcpConnection
channels_	Poller.h	/^  ChannelMap channels_;$/;"	m	class:muduo::net::Poller
checkEveryN_	LogFile.h	/^  const int checkEveryN_;$/;"	m	class:muduo::LogFile
clear	StringPiece.h	/^			void clear() { ptr_ = NULL; length_ = 0; }$/;"	f	class:muduo::StringPiece
clockTicksPerSecond	ProcessInfo.cc	/^int ProcessInfo::clockTicksPerSecond()$/;"	f	class:ProcessInfo
close	SocketsOps.cc	/^void sockets::close(int sockfd)$/;"	f	class:sockets
closeCallback_	Channel.h	/^				EventCallback closeCallback_;$/;"	m	class:muduo::net::Channel
closeCallback_	TcpConnection.h	/^				CloseCallback closeCallback_;$/;"	m	class:muduo::net::TcpConnection
compare	StringPiece.h	/^			int compare(const StringPiece& x) const {$/;"	f	class:muduo::StringPiece
compareGmt	TimeZone.cc	/^  bool compareGmt;$/;"	m	struct:muduo::detail::Comp
compress	ZlibStream.h	/^  int compress(int flush)$/;"	f	class:muduo::net::ZlibOutputStream
connect	Connector.cc	/^void Connector::connect()$/;"	f	class:Connector
connect	SocketsOps.cc	/^int sockets::connect(int sockfd, const struct sockaddr* addr)$/;"	f	class:sockets
connect	TcpClient.cc	/^void TcpClient::connect()$/;"	f	class:TcpClient
connectDestroyed	TcpConnection.cc	/^void TcpConnection::connectDestroyed()$/;"	f	class:TcpConnection
connectEstablished	TcpConnection.cc	/^void TcpConnection::connectEstablished()$/;"	f	class:TcpConnection
connect_	Connector.h	/^				bool connect_; \/\/ atomic$/;"	m	class:muduo::net::Connector
connect_	TcpClient.h	/^				bool connect_; \/\/ atomic$/;"	m	class:muduo::net::TcpClient
connected	TcpConnection.h	/^				bool connected() const { return state_ == kConnected; }$/;"	f	class:muduo::net::TcpConnection
connecting	Connector.cc	/^void Connector::connecting(int sockfd)$/;"	f	class:Connector
connection	TcpClient.h	/^				TcpConnectionPtr connection() const$/;"	f	class:muduo::net::TcpClient
connectionCallback_	TcpClient.h	/^				ConnectionCallback connectionCallback_;$/;"	m	class:muduo::net::TcpClient
connectionCallback_	TcpConnection.h	/^				ConnectionCallback connectionCallback_;$/;"	m	class:muduo::net::TcpConnection
connectionCallback_	TcpServer.h	/^				ConnectionCallback connectionCallback_;$/;"	m	class:muduo::net::TcpServer
connections_	TcpServer.h	/^				ConnectionMap connections_;$/;"	m	class:muduo::net::TcpServer
connector_	TcpClient.h	/^				ConnectorPtr connector_; \/\/ avoid revealing Connector$/;"	m	class:muduo::net::TcpClient
convert	LogStream.cc	/^			size_t convert(char buf[], T value)$/;"	f	namespace:muduo::detail
convertHex	LogStream.cc	/^		size_t convertHex(char buf[], uintptr_t value)$/;"	f	namespace:muduo::detail
cookieEnd	LogStream.cc	/^void FixedBuffer<SIZE>::cookieEnd()$/;"	f	class:FixedBuffer
cookieStart	LogStream.cc	/^void FixedBuffer<SIZE>::cookieStart()$/;"	f	class:FixedBuffer
cookie_	LogStream.h	/^				void (*cookie_)();$/;"	m	class:muduo::detail::FixedBuffer
copyable	copyable.h	/^class copyable$/;"	c	namespace:muduo
countDown	CountDownLatch.cc	/^void CountDownLatch::countDown()$/;"	f	class:CountDownLatch
count_	LogFile.h	/^  int count_;$/;"	m	class:muduo::LogFile
cpuTime	ProcessInfo.cc	/^ProcessInfo::CpuTime ProcessInfo::cpuTime()$/;"	f	class:ProcessInfo
createEventfd	EventLoop.cc	/^	int createEventfd()$/;"	f	namespace:__anon2
createNonblockingOrDie	SocketsOps.cc	/^int sockets::createNonblockingOrDie(sa_family_t family)$/;"	f	class:sockets
createTimerfd	TimerQueue.cc	/^			int createTimerfd()$/;"	f	namespace:muduo::net::detail
cur_	LogStream.h	/^				char* cur_;$/;"	m	class:muduo::detail::FixedBuffer
current	LogStream.h	/^				char* current() { return cur_; }$/;"	f	class:muduo::detail::FixedBuffer
currentActiveChannel_	EventLoop.h	/^				Channel* currentActiveChannel_;$/;"	m	class:muduo::net::EventLoop
data	LogStream.h	/^				const char* data() const { return data_; }$/;"	f	class:muduo::detail::FixedBuffer
data	LogStream.h	/^			const char* data() const { return buf_; }$/;"	f	class:muduo::Fmt
data	StringPiece.h	/^			const char* data() const { return ptr_; }$/;"	f	class:muduo::StringPiece
data_	LogStream.h	/^				char data_[SIZE];$/;"	m	class:muduo::detail::FixedBuffer
data_	Logging.h	/^					const char* data_;$/;"	m	class:muduo::Logger::SourceFile
data_	TimeZone.h	/^  std::shared_ptr<Data> data_;$/;"	m	class:muduo::TimeZone
day	Date.h	/^    int day;  \/\/ [1..31]$/;"	m	struct:muduo::Date::YearMonthDay
day	Date.h	/^  int day() const$/;"	f	class:muduo::Date
debugString	LogStream.cc	/^const char* FixedBuffer<SIZE>::debugString()$/;"	f	class:FixedBuffer
decltype	Singleton.h	/^  template <typename C> static char test(decltype(&C::no_destroy));$/;"	m	struct:muduo::detail::has_no_destroy
decrement	Atomic.h	/^  void decrement()$/;"	f	class:muduo::detail::AtomicIntegerT
decrementAndGet	Atomic.h	/^  T decrementAndGet()$/;"	f	class:muduo::detail::AtomicIntegerT
defaultConnectionCallback	TcpConnection.cc	/^void muduo::net::defaultConnectionCallback(const TcpConnectionPtr& conn)$/;"	f	class:muduo::net
defaultFlush	Logging.cc	/^	void defaultFlush()$/;"	f	namespace:muduo
defaultMessageCallback	TcpConnection.cc	/^void muduo::net::defaultMessageCallback(const TcpConnectionPtr&,$/;"	f	class:muduo::net
defaultOutput	Logging.cc	/^	void defaultOutput(const char* msg, int len)$/;"	f	namespace:muduo
deleter_	ThreadLocalSingleton.h	/^  static Deleter deleter_;$/;"	m	class:muduo::ThreadLocalSingleton
deleter_	ThreadLocalSingleton.h	/^typename ThreadLocalSingleton<T>::Deleter ThreadLocalSingleton<T>::deleter_;$/;"	m	class:muduo::ThreadLocalSingleton
destroy	Singleton.h	/^  static void destroy()$/;"	f	class:muduo::Singleton
destructor	ThreadLocal.h	/^  static void destructor(void *x)$/;"	f	class:muduo::ThreadLocal
destructor	ThreadLocalSingleton.h	/^  static void destructor(void* obj)$/;"	f	class:muduo::ThreadLocalSingleton
detail	Atomic.h	/^namespace detail$/;"	n	namespace:muduo
detail	Date.cc	/^namespace detail$/;"	n	namespace:muduo
detail	LogStream.cc	/^	namespace detail$/;"	n	namespace:muduo
detail	LogStream.h	/^	namespace detail$/;"	n	namespace:muduo
detail	ProcessInfo.cc	/^namespace detail$/;"	n	namespace:muduo
detail	Singleton.h	/^namespace detail$/;"	n	namespace:muduo
detail	TcpClient.cc	/^		namespace detail$/;"	n	namespace:muduo::net
detail	Thread.cc	/^	namespace detail$/;"	n	namespace:muduo
detail	TimeZone.cc	/^namespace detail$/;"	n	namespace:muduo
detail	TimerQueue.cc	/^		namespace detail$/;"	n	namespace:muduo::net
digits	LogStream.cc	/^		const char digits[] = "9876543210123456789";$/;"	m	namespace:muduo::detail
digitsHex	LogStream.cc	/^		const char digitsHex[] = "0123456789ABCDEF";$/;"	m	namespace:muduo::detail
disableAll	Channel.h	/^				void disableAll() { events_ = kNoneEvent; update(); }$/;"	f	class:muduo::net::Channel
disableReading	Channel.h	/^				void disableReading() { events_ &= ~kReadEvent; update(); }$/;"	f	class:muduo::net::Channel
disableWriting	Channel.h	/^				void disableWriting() { events_ &= ~kWriteEvent; update(); }$/;"	f	class:muduo::net::Channel
disconnect	TcpClient.cc	/^void TcpClient::disconnect()$/;"	f	class:TcpClient
disconnected	TcpConnection.h	/^				bool disconnected() const { return state_ == kDisconnected; }$/;"	f	class:muduo::net::TcpConnection
doNotLogHup	Channel.h	/^				void doNotLogHup() { logHup_ = false; }$/;"	f	class:muduo::net::Channel
doPendingFunctors	EventLoop.cc	/^void EventLoop::doPendingFunctors()$/;"	f	class:EventLoop
down_cast	Types.h	/^inline To down_cast(From* f)                     \/\/ so we only accept pointers$/;"	f	namespace:muduo
down_pointer_cast	Callbacks.h	/^inline ::std::shared_ptr<To> down_pointer_cast(const ::std::shared_ptr<From>& f) {$/;"	f	namespace:muduo
empty	BoundedBlockingQueue.h	/^  bool empty() const$/;"	f	class:muduo::BoundedBlockingQueue
empty	StringPiece.h	/^			bool empty() const { return length_ == 0; }$/;"	f	class:muduo::StringPiece
enableReading	Channel.h	/^				void enableReading() { events_ |= kReadEvent; update(); }$/;"	f	class:muduo::net::Channel
enableRetry	TcpClient.h	/^				void enableRetry() { retry_ = true; }$/;"	f	class:muduo::net::TcpClient
enableWriting	Channel.h	/^				void enableWriting() { events_ |= kWriteEvent; update(); }$/;"	f	class:muduo::net::Channel
end	LogStream.h	/^				const char* end() const { return data_ + sizeof data_; }$/;"	f	class:muduo::detail::FixedBuffer
end	StringPiece.h	/^			const char* end() const { return ptr_ + length_; }$/;"	f	class:muduo::StringPiece
ensureWritableBytes	Buffer.h	/^				void ensureWritableBytes(size_t len)$/;"	f	class:muduo::net::Buffer
epollfd_	EPollPoller.h	/^				int epollfd_;$/;"	m	class:muduo::net::EPollPoller
equal	TimeZone.cc	/^  bool equal(const Transition& lhs, const Transition& rhs) const$/;"	f	struct:muduo::detail::Comp
err_	FileUtil.h	/^  int err_;$/;"	m	class:muduo::FileUtil::ReadSmallFile
errorCallback_	Channel.h	/^				EventCallback errorCallback_;$/;"	m	class:muduo::net::Channel
euid	ProcessInfo.cc	/^uid_t ProcessInfo::euid()$/;"	f	class:ProcessInfo
eventHandling	EventLoop.h	/^				bool eventHandling() const { return eventHandling_; }$/;"	f	class:muduo::net::EventLoop
eventHandling_	Channel.h	/^				bool eventHandling_;$/;"	m	class:muduo::net::Channel
eventHandling_	EventLoop.h	/^				bool eventHandling_; \/* atomic *\/$/;"	m	class:muduo::net::EventLoop
events	Channel.h	/^				int events() const { return events_; }$/;"	f	class:muduo::net::Channel
eventsToString	Channel.cc	/^string Channel::eventsToString() const$/;"	f	class:Channel
eventsToString	Channel.cc	/^string Channel::eventsToString(int fd, int ev)$/;"	f	class:Channel
events_	Channel.h	/^				int        events_;$/;"	m	class:muduo::net::Channel
events_	EPollPoller.h	/^				EventList events_;$/;"	m	class:muduo::net::EPollPoller
exePath	ProcessInfo.cc	/^string ProcessInfo::exePath()$/;"	f	class:ProcessInfo
exiting_	EventLoopThread.h	/^				bool exiting_;$/;"	m	class:muduo::net::EventLoopThread
expiration	Timer.h	/^  Timestamp expiration() const  { return expiration_; }$/;"	f	class:muduo::net::Timer
expiration_	Timer.h	/^  Timestamp expiration_;$/;"	m	class:muduo::net::Timer
family	InetAddress.h	/^				sa_family_t family() const { return addr_.sin_family; }$/;"	f	class:muduo::net::InetAddress
fd	Channel.h	/^				int fd() const { return fd_; }$/;"	f	class:muduo::net::Channel
fd	Socket.h	/^				int fd() const { return sockfd_; }$/;"	f	class:muduo::net::Socket
fdDirFilter	ProcessInfo.cc	/^int fdDirFilter(const struct dirent* d)$/;"	f	namespace:muduo::detail
fd_	Channel.h	/^				const int  fd_;$/;"	m	class:muduo::net::Channel
fd_	FileUtil.h	/^  int fd_;$/;"	m	class:muduo::FileUtil::ReadSmallFile
file_	GzipFile.h	/^    : file_(rhs.file_)$/;"	f	class:muduo::GzipFile
file_	GzipFile.h	/^  gzFile file_;$/;"	m	class:muduo::GzipFile
file_	LogFile.h	/^  std::unique_ptr<FileUtil::AppendFile> file_;$/;"	m	class:muduo::LogFile
fillActiveChannels	EPollPoller.cc	/^void EPollPoller::fillActiveChannels(int numEvents,$/;"	f	class:EPollPoller
fillActiveChannels	PollPoller.cc	/^void PollPoller::fillActiveChannels(int numEvents,$/;"	f	class:PollPoller
fillHMS	TimeZone.cc	/^inline void fillHMS(unsigned seconds, struct tm* utc)$/;"	f	namespace:muduo::detail
findCRLF	Buffer.h	/^				const char* findCRLF() const$/;"	f	class:muduo::net::Buffer
findCRLF	Buffer.h	/^				const char* findCRLF(const char* start) const$/;"	f	class:muduo::net::Buffer
findEOL	Buffer.h	/^				const char* findEOL() const$/;"	f	class:muduo::net::Buffer
findEOL	Buffer.h	/^				const char* findEOL(const char* start) const$/;"	f	class:muduo::net::Buffer
findLocaltime	TimeZone.cc	/^const Localtime* findLocaltime(const TimeZone::Data& data, Transition sentry, Comp comp)$/;"	f	namespace:muduo::detail
finish	Logging.cc	/^void Logger::Impl::finish()$/;"	f	class:Logger::Impl
finish	ZlibStream.h	/^  bool finish()$/;"	f	class:muduo::net::ZlibOutputStream
flush	FileUtil.cc	/^void FileUtil::AppendFile::flush()$/;"	f	class:FileUtil::AppendFile
flush	LogFile.cc	/^void LogFile::flush()$/;"	f	class:LogFile
flushInterval_	AsyncLogging.h	/^  const int flushInterval_;$/;"	m	class:muduo::AsyncLogging
flushInterval_	LogFile.h	/^  const int flushInterval_;$/;"	m	class:muduo::LogFile
forceClose	TcpConnection.cc	/^void TcpConnection::forceClose()$/;"	f	class:TcpConnection
forceCloseInLoop	TcpConnection.cc	/^void TcpConnection::forceCloseInLoop()$/;"	f	class:TcpConnection
forceCloseWithDelay	TcpConnection.cc	/^void TcpConnection::forceCloseWithDelay(double seconds)$/;"	f	class:TcpConnection
formatIEC	LogStream.cc	/^	std::string formatIEC(int64_t s)$/;"	f	namespace:muduo
formatInteger	LogStream.cc	/^void LogStream::formatInteger(T v)$/;"	f	class:LogStream
formatSI	LogStream.cc	/^	std::string formatSI(int64_t s)$/;"	f	namespace:muduo
formatTime	Logging.cc	/^void Logger::Impl::formatTime()$/;"	f	class:Logger::Impl
fp_	FileUtil.h	/^  FILE* fp_;$/;"	m	class:muduo::FileUtil::AppendFile
fp_	TimeZone.cc	/^  FILE* fp_;$/;"	m	class:muduo::detail::File
fromIpPort	SocketsOps.cc	/^void sockets::fromIpPort(const char* ip, uint16_t port,$/;"	f	class:sockets
fromLocalTime	TimeZone.cc	/^time_t TimeZone::fromLocalTime(const struct tm& localTm) const$/;"	f	class:TimeZone
fromUnixTime	Timestamp.h	/^  static Timestamp fromUnixTime(time_t t)$/;"	f	class:muduo::Timestamp
fromUnixTime	Timestamp.h	/^  static Timestamp fromUnixTime(time_t t, int microseconds)$/;"	f	class:muduo::Timestamp
fromUtcTime	TimeZone.cc	/^time_t TimeZone::fromUtcTime(const struct tm& utc)$/;"	f	class:TimeZone
fromUtcTime	TimeZone.cc	/^time_t TimeZone::fromUtcTime(int year, int month, int day,$/;"	f	class:TimeZone
full	BoundedBlockingQueue.h	/^  bool full() const$/;"	f	class:muduo::BoundedBlockingQueue
func_	Thread.cc	/^			ThreadFunc func_;$/;"	m	struct:muduo::detail::ThreadData
func_	Thread.h	/^			ThreadFunc func_;$/;"	m	class:muduo::Thread
function_	WeakCallback.h	/^  std::function<void (CLASS*, ARGS...)> function_;$/;"	m	class:muduo::WeakCallback
g_clockTicks	ProcessInfo.cc	/^int g_clockTicks = static_cast<int>(::sysconf(_SC_CLK_TCK));$/;"	m	namespace:muduo::detail
g_flush	Logging.cc	/^	Logger::FlushFunc g_flush = defaultFlush;$/;"	m	namespace:muduo
g_logLevel	Logging.cc	/^	Logger::LogLevel g_logLevel = initLogLevel();$/;"	m	namespace:muduo
g_logTimeZone	Logging.cc	/^	TimeZone g_logTimeZone;$/;"	m	namespace:muduo
g_output	Logging.cc	/^	Logger::OutputFunc g_output = defaultOutput;$/;"	m	namespace:muduo
g_pageSize	ProcessInfo.cc	/^int g_pageSize = static_cast<int>(::sysconf(_SC_PAGE_SIZE));$/;"	m	namespace:muduo::detail
g_startTime	ProcessInfo.cc	/^Timestamp g_startTime = Timestamp::now();$/;"	m	namespace:muduo::detail
get	Atomic.h	/^  T get()$/;"	f	class:muduo::detail::AtomicIntegerT
getAllLoops	EventLoopThreadPool.cc	/^std::vector<EventLoop*> EventLoopThreadPool::getAllLoops()$/;"	f	class:EventLoopThreadPool
getAndAdd	Atomic.h	/^  T getAndAdd(T x)$/;"	f	class:muduo::detail::AtomicIntegerT
getAndSet	Atomic.h	/^  T getAndSet(T newValue)$/;"	f	class:muduo::detail::AtomicIntegerT
getCount	CountDownLatch.cc	/^int CountDownLatch::getCount() const$/;"	f	class:CountDownLatch
getEventLoopOfCurrentThread	EventLoop.cc	/^EventLoop* EventLoop::getEventLoopOfCurrentThread()$/;"	f	class:EventLoop
getExpired	TimerQueue.cc	/^std::vector<TimerQueue::Entry> TimerQueue::getExpired(Timestamp now)$/;"	f	class:TimerQueue
getJulianDayNumber	Date.cc	/^int getJulianDayNumber(int year, int month, int day)$/;"	f	namespace:muduo::detail
getLocalAddr	SocketsOps.cc	/^struct sockaddr_in6 sockets::getLocalAddr(int sockfd)$/;"	f	class:sockets
getLogFileName	LogFile.cc	/^string LogFile::getLogFileName(const string& basename, time_t* now)$/;"	f	class:LogFile
getLoop	TcpClient.h	/^				EventLoop* getLoop() const { return loop_; }$/;"	f	class:muduo::net::TcpClient
getLoop	TcpConnection.h	/^				EventLoop* getLoop() const { return loop_; }$/;"	f	class:muduo::net::TcpConnection
getLoop	TcpServer.h	/^				EventLoop* getLoop() const { return loop_; }$/;"	f	class:muduo::net::TcpServer
getLoopForHash	EventLoopThreadPool.cc	/^EventLoop* EventLoopThreadPool::getLoopForHash(size_t hashCode)$/;"	f	class:EventLoopThreadPool
getNextLoop	EventLoopThreadPool.cc	/^EventLoop* EventLoopThreadPool::getNextLoop()$/;"	f	class:EventLoopThreadPool
getPeerAddr	SocketsOps.cc	/^struct sockaddr_in6 sockets::getPeerAddr(int sockfd)$/;"	f	class:sockets
getSockAddr	InetAddress.h	/^				const struct sockaddr* getSockAddr() const { return sockets::sockaddr_cast(&addr6_); }$/;"	f	class:muduo::net::InetAddress
getSocketError	SocketsOps.cc	/^int sockets::getSocketError(int sockfd)$/;"	f	class:sockets
getTcpInfo	Socket.cc	/^bool Socket::getTcpInfo(struct tcp_info* tcpi) const$/;"	f	class:Socket
getTcpInfo	TcpConnection.cc	/^bool TcpConnection::getTcpInfo(struct tcp_info* tcpi) const$/;"	f	class:TcpConnection
getTcpInfoString	Socket.cc	/^bool Socket::getTcpInfoString(char* buf, int len) const$/;"	f	class:Socket
getTcpInfoString	TcpConnection.cc	/^string TcpConnection::getTcpInfoString() const$/;"	f	class:TcpConnection
getYearMonthDay	Date.cc	/^struct Date::YearMonthDay getYearMonthDay(int julianDayNumber)$/;"	f	namespace:muduo::detail
get_pointer	Callbacks.h	/^inline T* get_pointer(const std::shared_ptr<T>& ptr)$/;"	f	namespace:muduo
get_pointer	Callbacks.h	/^inline T* get_pointer(const std::unique_ptr<T>& ptr)$/;"	f	namespace:muduo
gettid	Thread.cc	/^		pid_t gettid()$/;"	f	namespace:muduo::detail
gmtOffset	TimeZone.cc	/^  time_t gmtOffset;$/;"	m	struct:muduo::detail::Localtime
gmttime	TimeZone.cc	/^  time_t gmttime;$/;"	m	struct:muduo::detail::Transition
handleClose	TcpConnection.cc	/^void TcpConnection::handleClose()$/;"	f	class:TcpConnection
handleError	Connector.cc	/^void Connector::handleError()$/;"	f	class:Connector
handleError	TcpConnection.cc	/^void TcpConnection::handleError()$/;"	f	class:TcpConnection
handleEvent	Channel.cc	/^void Channel::handleEvent(Timestamp receiveTime)$/;"	f	class:Channel
handleEventWithGuard	Channel.cc	/^void Channel::handleEventWithGuard(Timestamp receiveTime)$/;"	f	class:Channel
handleRead	Acceptor.cc	/^void Acceptor::handleRead()$/;"	f	class:Acceptor
handleRead	EventLoop.cc	/^void EventLoop::handleRead()$/;"	f	class:EventLoop
handleRead	TcpConnection.cc	/^void TcpConnection::handleRead(Timestamp receiveTime)$/;"	f	class:TcpConnection
handleRead	TimerQueue.cc	/^void TimerQueue::handleRead()$/;"	f	class:TimerQueue
handleWrite	Connector.cc	/^void Connector::handleWrite()$/;"	f	class:Connector
handleWrite	TcpConnection.cc	/^void TcpConnection::handleWrite()$/;"	f	class:TcpConnection
hasChannel	EventLoop.cc	/^bool EventLoop::hasChannel(Channel* channel)$/;"	f	class:EventLoop
hasChannel	Poller.cc	/^bool Poller::hasChannel(Channel* channel) const$/;"	f	class:Poller
hasWritten	Buffer.h	/^				void hasWritten(size_t len)$/;"	f	class:muduo::net::Buffer
has_no_destroy	Singleton.h	/^struct has_no_destroy$/;"	s	namespace:muduo::detail
has_trivial_assignment_operator	StringPiece.h	/^	typedef __true_type    has_trivial_assignment_operator;$/;"	t	struct:__type_traits
has_trivial_copy_constructor	StringPiece.h	/^	typedef __true_type    has_trivial_copy_constructor;$/;"	t	struct:__type_traits
has_trivial_default_constructor	StringPiece.h	/^	typedef __true_type    has_trivial_default_constructor;$/;"	t	struct:__type_traits
has_trivial_destructor	StringPiece.h	/^	typedef __true_type    has_trivial_destructor;$/;"	t	struct:__type_traits
highWaterMarkCallback_	TcpConnection.h	/^				HighWaterMarkCallback highWaterMarkCallback_;$/;"	m	class:muduo::net::TcpConnection
highWaterMark_	TcpConnection.h	/^				size_t highWaterMark_;$/;"	m	class:muduo::net::TcpConnection
hostToNetwork16	Endian.h	/^inline uint16_t hostToNetwork16(uint16_t host16)$/;"	f	namespace:muduo::net::sockets
hostToNetwork32	Endian.h	/^inline uint32_t hostToNetwork32(uint32_t host32)$/;"	f	namespace:muduo::net::sockets
hostToNetwork64	Endian.h	/^inline uint64_t hostToNetwork64(uint64_t host64)$/;"	f	namespace:muduo::net::sockets
hostname	ProcessInfo.cc	/^string ProcessInfo::hostname()$/;"	f	class:ProcessInfo
howMuchTimeFromNow	TimerQueue.cc	/^			struct timespec howMuchTimeFromNow(Timestamp when)$/;"	f	namespace:muduo::net::detail
idleFd_	Acceptor.h	/^				int idleFd_;$/;"	m	class:muduo::net::Acceptor
impl_	Logging.h	/^			Impl impl_;$/;"	m	class:muduo::Logger
implicit_cast	Types.h	/^inline To implicit_cast(From const &f)$/;"	f	namespace:muduo
increment	Atomic.h	/^  void increment()$/;"	f	class:muduo::detail::AtomicIntegerT
incrementAndGet	Atomic.h	/^  T incrementAndGet()$/;"	f	class:muduo::detail::AtomicIntegerT
index	Channel.h	/^				int index() { return index_; }$/;"	f	class:muduo::net::Channel
index_	Channel.h	/^				int        index_; \/\/ used by Poller.$/;"	m	class:muduo::net::Channel
init	Singleton.h	/^  static void init()$/;"	f	class:muduo::Singleton
init	Thread.cc	/^		ThreadNameInitializer init;$/;"	m	namespace:muduo::detail
initLogLevel	Logging.cc	/^	Logger::LogLevel initLogLevel()$/;"	f	namespace:muduo
initObj	EventLoop.cc	/^	IgnoreSigPipe initObj;$/;"	m	namespace:__anon2
inputBuffer	TcpConnection.h	/^				Buffer* inputBuffer()$/;"	f	class:muduo::net::TcpConnection
inputBuffer_	TcpConnection.h	/^				Buffer inputBuffer_;$/;"	m	class:muduo::net::TcpConnection
inputBytes	ZlibStream.h	/^  int64_t inputBytes() const { return zstream_.total_in; }$/;"	f	class:muduo::net::ZlibOutputStream
insert	TimerQueue.cc	/^bool TimerQueue::insert(Timer* timer)$/;"	f	class:TimerQueue
instance	Singleton.h	/^  static T& instance()$/;"	f	class:muduo::Singleton
instance	ThreadLocalSingleton.h	/^  static T& instance()$/;"	f	class:muduo::ThreadLocalSingleton
internalCapacity	Buffer.h	/^				size_t internalCapacity() const$/;"	f	class:muduo::net::Buffer
internalOutputBufferSize	ZlibStream.h	/^  int internalOutputBufferSize() const { return bufferSize_; }$/;"	f	class:muduo::net::ZlibOutputStream
interval_	Timer.h	/^  const double interval_;$/;"	m	class:muduo::net::Timer
invalid	Timestamp.h	/^  static Timestamp invalid()$/;"	f	class:muduo::Timestamp
ipNetEndian	InetAddress.cc	/^uint32_t InetAddress::ipNetEndian() const$/;"	f	class:InetAddress
ipPort	TcpServer.h	/^				const string& ipPort() const { return ipPort_; }$/;"	f	class:muduo::net::TcpServer
ipPort_	TcpServer.h	/^				const string ipPort_;$/;"	m	class:muduo::net::TcpServer
isDebugBuild	ProcessInfo.cc	/^bool ProcessInfo::isDebugBuild()$/;"	f	class:ProcessInfo
isDst	TimeZone.cc	/^  bool isDst;$/;"	m	struct:muduo::detail::Localtime
isFull	ThreadPool.cc	/^bool ThreadPool::isFull() const$/;"	f	class:ThreadPool
isInLoopThread	EventLoop.h	/^				bool isInLoopThread() const { return threadId_ == CurrentThread::tid(); }$/;"	f	class:muduo::net::EventLoop
isMainThread	Thread.cc	/^	bool CurrentThread::isMainThread()$/;"	f	class:muduo::CurrentThread
isNoneEvent	Channel.h	/^				bool isNoneEvent() const { return events_ == kNoneEvent; }$/;"	f	class:muduo::net::Channel
isReading	Channel.h	/^				bool isReading() const { return events_ & kReadEvent; }$/;"	f	class:muduo::net::Channel
isReading	TcpConnection.h	/^				bool isReading() const { return reading_; }; \/\/ NOT thread safe, may race with start\/stopReadInLoop$/;"	f	class:muduo::net::TcpConnection
isSelfConnect	SocketsOps.cc	/^bool sockets::isSelfConnect(int sockfd)$/;"	f	class:sockets
isWriting	Channel.h	/^				bool isWriting() const { return events_ & kWriteEvent; }$/;"	f	class:muduo::net::Channel
is_POD_type	StringPiece.h	/^	typedef __true_type    is_POD_type;$/;"	t	struct:__type_traits
iteration	EventLoop.h	/^				int64_t iteration() const { return iteration_; }$/;"	f	class:muduo::net::EventLoop
iteration_	EventLoop.h	/^				int64_t iteration_;$/;"	m	class:muduo::net::EventLoop
join	Thread.cc	/^	int Thread::join()$/;"	f	class:muduo::Thread
joined_	Thread.h	/^			bool       joined_;$/;"	m	class:muduo::Thread
julianDayNumber	Date.h	/^  int julianDayNumber() const { return julianDayNumber_; }$/;"	f	class:muduo::Date
julianDayNumber_	Date.h	/^  int julianDayNumber_;$/;"	m	class:muduo::Date
kAdded	EPollPoller.cc	/^	const int kAdded = 1;$/;"	m	namespace:__anon4
kBufferSize	FileUtil.h	/^  static const int kBufferSize = 64*1024;$/;"	m	class:muduo::FileUtil::ReadSmallFile
kCRLF	Buffer.cc	/^const char Buffer::kCRLF[] = "\\r\\n";$/;"	m	class:Buffer
kCRLF	Buffer.h	/^				static const char kCRLF[];$/;"	m	class:muduo::net::Buffer
kCheapPrepend	Buffer.cc	/^const size_t Buffer::kCheapPrepend;$/;"	m	class:Buffer
kCheapPrepend	Buffer.h	/^				static const size_t kCheapPrepend = 8;$/;"	m	class:muduo::net::Buffer
kConnected	Connector.h	/^				enum States { kDisconnected, kConnecting, kConnected };$/;"	e	enum:muduo::net::Connector::States
kConnected	TcpConnection.h	/^				enum StateE { kDisconnected, kConnecting, kConnected, kDisconnecting };$/;"	e	enum:muduo::net::TcpConnection::StateE
kConnecting	Connector.h	/^				enum States { kDisconnected, kConnecting, kConnected };$/;"	e	enum:muduo::net::Connector::States
kConnecting	TcpConnection.h	/^				enum StateE { kDisconnected, kConnecting, kConnected, kDisconnecting };$/;"	e	enum:muduo::net::TcpConnection::StateE
kDaysPerWeek	Date.h	/^  static const int kDaysPerWeek = 7;$/;"	m	class:muduo::Date
kDeleted	EPollPoller.cc	/^	const int kDeleted = 2;$/;"	m	namespace:__anon4
kDisconnected	Connector.h	/^				enum States { kDisconnected, kConnecting, kConnected };$/;"	e	enum:muduo::net::Connector::States
kDisconnected	TcpConnection.h	/^				enum StateE { kDisconnected, kConnecting, kConnected, kDisconnecting };$/;"	e	enum:muduo::net::TcpConnection::StateE
kDisconnecting	TcpConnection.h	/^				enum StateE { kDisconnected, kConnecting, kConnected, kDisconnecting };$/;"	e	enum:muduo::net::TcpConnection::StateE
kInaddrAny	InetAddress.cc	/^static const in_addr_t kInaddrAny = INADDR_ANY;$/;"	v
kInaddrLoopback	InetAddress.cc	/^static const in_addr_t kInaddrLoopback = INADDR_LOOPBACK;$/;"	v
kInitEventListSize	EPollPoller.h	/^				static const int kInitEventListSize = 16;$/;"	m	class:muduo::net::EPollPoller
kInitRetryDelayMs	Connector.h	/^				static const int kInitRetryDelayMs = 500;$/;"	m	class:muduo::net::Connector
kInitialSize	Buffer.cc	/^const size_t Buffer::kInitialSize;$/;"	m	class:Buffer
kInitialSize	Buffer.h	/^				static const size_t kInitialSize = 1024;$/;"	m	class:muduo::net::Buffer
kJulianDayOf1970_01_01	Date.cc	/^const int Date::kJulianDayOf1970_01_01 = detail::getJulianDayNumber(1970, 1, 1);$/;"	m	class:muduo::Date
kJulianDayOf1970_01_01	Date.h	/^  static const int kJulianDayOf1970_01_01;$/;"	m	class:muduo::Date
kLargeBuffer	LogStream.h	/^		const int kLargeBuffer = 4000*1000;$/;"	m	namespace:muduo::detail
kMaxNumericSize	LogStream.h	/^		static const int kMaxNumericSize = 32;$/;"	m	class:muduo::LogStream
kMaxRetryDelayMs	Connector.cc	/^const int Connector::kMaxRetryDelayMs;$/;"	m	class:Connector
kMaxRetryDelayMs	Connector.h	/^				static const int kMaxRetryDelayMs = 30*1000;$/;"	m	class:muduo::net::Connector
kMicroSecondsPerSecond	Timestamp.h	/^  static const int kMicroSecondsPerSecond = 1000 * 1000;$/;"	m	class:muduo::Timestamp
kNew	EPollPoller.cc	/^	const int kNew = -1;$/;"	m	namespace:__anon4
kNoReusePort	TcpServer.h	/^					kNoReusePort,$/;"	e	enum:muduo::net::TcpServer::Option
kNoneEvent	Channel.cc	/^const int Channel::kNoneEvent = 0;$/;"	m	class:Channel
kNoneEvent	Channel.h	/^				static const int kNoneEvent;$/;"	m	class:muduo::net::Channel
kPollTimeMs	EventLoop.cc	/^	const int kPollTimeMs = 10000;$/;"	m	namespace:__anon2
kReadEvent	Channel.cc	/^const int Channel::kReadEvent = POLLIN | POLLPRI;$/;"	m	class:Channel
kReadEvent	Channel.h	/^				static const int kReadEvent;$/;"	m	class:muduo::net::Channel
kReusePort	TcpServer.h	/^					kReusePort,$/;"	e	enum:muduo::net::TcpServer::Option
kRollPerSeconds_	LogFile.h	/^  const static int kRollPerSeconds_ = 60*60*24;$/;"	m	class:muduo::LogFile
kSecondsPerDay	TimeZone.cc	/^const int kSecondsPerDay = 24*60*60;$/;"	m	namespace:muduo
kSmallBuffer	LogStream.h	/^		const int kSmallBuffer = 4000;$/;"	m	namespace:muduo::detail
kWriteEvent	Channel.cc	/^const int Channel::kWriteEvent = POLLOUT;$/;"	m	class:Channel
kWriteEvent	Channel.h	/^				static const int kWriteEvent;$/;"	m	class:muduo::net::Channel
lastFlush_	LogFile.h	/^  time_t lastFlush_;$/;"	m	class:muduo::LogFile
lastRoll_	LogFile.h	/^  time_t lastRoll_;$/;"	m	class:muduo::LogFile
latch_	AsyncLogging.h	/^  muduo::CountDownLatch latch_;$/;"	m	class:muduo::AsyncLogging
latch_	Thread.cc	/^			CountDownLatch* latch_;$/;"	m	struct:muduo::detail::ThreadData
latch_	Thread.h	/^			CountDownLatch latch_;$/;"	m	class:muduo::Thread
len_	Logging.cc	/^			const unsigned len_;$/;"	m	class:muduo::T
length	LogStream.h	/^				int length() const { return static_cast<int>(cur_ - data_); }$/;"	f	class:muduo::detail::FixedBuffer
length	LogStream.h	/^			int length() const { return length_; }$/;"	f	class:muduo::Fmt
length_	LogStream.h	/^			int length_;$/;"	m	class:muduo::Fmt
length_	StringPiece.h	/^			int           length_;$/;"	m	class:muduo::StringPiece
level_	Logging.h	/^					LogLevel level_;$/;"	m	class:muduo::Logger::Impl
line_	Logging.h	/^					int line_;$/;"	m	class:muduo::Logger::Impl
listen	Acceptor.cc	/^void Acceptor::listen()$/;"	f	class:Acceptor
listen	Socket.cc	/^void Socket::listen()$/;"	f	class:Socket
listenOrDie	SocketsOps.cc	/^void sockets::listenOrDie(int sockfd)$/;"	f	class:sockets
listenning	Acceptor.h	/^				bool listenning() const { return listenning_; }$/;"	f	class:muduo::net::Acceptor
listenning_	Acceptor.h	/^				bool listenning_;$/;"	m	class:muduo::net::Acceptor
localAddr_	TcpConnection.h	/^				const InetAddress localAddr_;$/;"	m	class:muduo::net::TcpConnection
localAddress	TcpConnection.h	/^				const InetAddress& localAddress() const { return localAddr_; }$/;"	f	class:muduo::net::TcpConnection
localtime	TimeZone.cc	/^  time_t localtime;$/;"	m	struct:muduo::detail::Transition
localtimeIdx	TimeZone.cc	/^  int localtimeIdx;$/;"	m	struct:muduo::detail::Transition
localtimes	TimeZone.cc	/^  vector<detail::Localtime> localtimes;$/;"	m	struct:TimeZone::Data
logHup_	Channel.h	/^				bool       logHup_;$/;"	m	class:muduo::net::Channel
logLevel	Logging.h	/^	inline Logger::LogLevel Logger::logLevel()$/;"	f	class:muduo::Logger
loop	EventLoop.cc	/^void EventLoop::loop()$/;"	f	class:EventLoop
loop_	Acceptor.h	/^				EventLoop* loop_;$/;"	m	class:muduo::net::Acceptor
loop_	Channel.h	/^				EventLoop* loop_;$/;"	m	class:muduo::net::Channel
loop_	Connector.h	/^				EventLoop* loop_;$/;"	m	class:muduo::net::Connector
loop_	TcpClient.h	/^				EventLoop* loop_;$/;"	m	class:muduo::net::TcpClient
loop_	TcpConnection.h	/^				EventLoop* loop_;$/;"	m	class:muduo::net::TcpConnection
loop_	TcpServer.h	/^				EventLoop* loop_;  \/\/ the acceptor loop$/;"	m	class:muduo::net::TcpServer
loop_	TimerQueue.h	/^  EventLoop* loop_;$/;"	m	class:muduo::net::TimerQueue
looping_	EventLoop.h	/^				bool looping_; \/* atomic *\/$/;"	m	class:muduo::net::EventLoop
loops_	EventLoopThreadPool.h	/^  std::vector<EventLoop*> loops_;$/;"	m	class:muduo::net::EventLoopThreadPool
makeSpace	Buffer.h	/^				void makeSpace(size_t len)$/;"	f	class:muduo::net::Buffer
makeWeakCallback	WeakCallback.h	/^WeakCallback<CLASS, ARGS...> makeWeakCallback(const std::shared_ptr<CLASS>& object,$/;"	f	namespace:muduo
maxOpenFiles	ProcessInfo.cc	/^int ProcessInfo::maxOpenFiles()$/;"	f	class:ProcessInfo
maxQueueSize_	ThreadPool.h	/^  size_t maxQueueSize_;$/;"	m	class:muduo::ThreadPool
memZero	Types.h	/^inline void memZero(void* p, size_t n)$/;"	f	namespace:muduo
messageCallback_	TcpClient.h	/^				MessageCallback messageCallback_;$/;"	m	class:muduo::net::TcpClient
messageCallback_	TcpConnection.h	/^				MessageCallback messageCallback_;$/;"	m	class:muduo::net::TcpConnection
messageCallback_	TcpServer.h	/^				MessageCallback messageCallback_;$/;"	m	class:muduo::net::TcpServer
message_	Exception.h	/^  string message_;$/;"	m	class:muduo::Exception
microSecondsSinceEpoch	Timestamp.h	/^  int64_t microSecondsSinceEpoch() const { return microSecondsSinceEpoch_; }$/;"	f	class:muduo::Timestamp
microSecondsSinceEpoch_	Timestamp.h	/^  int64_t microSecondsSinceEpoch_;$/;"	m	class:muduo::Timestamp
month	Date.h	/^    int month;  \/\/ [1..12]$/;"	m	struct:muduo::Date::YearMonthDay
month	Date.h	/^  int month() const$/;"	f	class:muduo::Date
muduo	Acceptor.h	/^namespace muduo$/;"	n
muduo	AsyncLogging.h	/^namespace muduo$/;"	n
muduo	Atomic.h	/^namespace muduo$/;"	n
muduo	BlockingQueue.h	/^namespace muduo$/;"	n
muduo	BoundedBlockingQueue.h	/^namespace muduo$/;"	n
muduo	Buffer.h	/^namespace muduo$/;"	n
muduo	Callbacks.h	/^namespace muduo$/;"	n
muduo	Channel.h	/^namespace muduo$/;"	n
muduo	Condition.h	/^namespace muduo$/;"	n
muduo	Connector.h	/^namespace muduo$/;"	n
muduo	CountDownLatch.h	/^namespace muduo$/;"	n
muduo	CurrentThread.cc	/^namespace muduo$/;"	n
muduo	CurrentThread.h	/^namespace muduo$/;"	n
muduo	Date.cc	/^namespace muduo$/;"	n
muduo	Date.h	/^namespace muduo$/;"	n
muduo	EPollPoller.h	/^namespace muduo$/;"	n
muduo	Endian.h	/^namespace muduo$/;"	n
muduo	EventLoop.h	/^namespace muduo$/;"	n
muduo	EventLoopThread.h	/^namespace muduo$/;"	n
muduo	EventLoopThreadPool.h	/^namespace muduo$/;"	n
muduo	Exception.cc	/^namespace muduo$/;"	n
muduo	Exception.h	/^namespace muduo$/;"	n
muduo	FileUtil.h	/^namespace muduo$/;"	n
muduo	GzipFile.h	/^namespace muduo$/;"	n
muduo	InetAddress.h	/^namespace muduo$/;"	n
muduo	LogFile.h	/^namespace muduo$/;"	n
muduo	LogStream.cc	/^namespace muduo$/;"	n
muduo	LogStream.h	/^namespace muduo$/;"	n
muduo	Logging.cc	/^namespace muduo$/;"	n
muduo	Logging.h	/^namespace muduo$/;"	n
muduo	Mutex.h	/^namespace muduo$/;"	n
muduo	PollPoller.h	/^namespace muduo$/;"	n
muduo	Poller.h	/^namespace muduo$/;"	n
muduo	ProcessInfo.cc	/^namespace muduo$/;"	n
muduo	ProcessInfo.h	/^namespace muduo$/;"	n
muduo	Singleton.h	/^namespace muduo$/;"	n
muduo	Socket.h	/^namespace muduo$/;"	n
muduo	SocketsOps.h	/^namespace muduo$/;"	n
muduo	StringPiece.h	/^namespace muduo$/;"	n
muduo	TcpClient.cc	/^namespace muduo$/;"	n
muduo	TcpClient.h	/^namespace muduo$/;"	n
muduo	TcpConnection.h	/^namespace muduo$/;"	n
muduo	TcpServer.h	/^namespace muduo$/;"	n
muduo	Thread.cc	/^namespace muduo$/;"	n
muduo	Thread.h	/^namespace muduo$/;"	n
muduo	ThreadLocal.h	/^namespace muduo$/;"	n
muduo	ThreadLocalSingleton.h	/^namespace muduo$/;"	n
muduo	ThreadPool.h	/^namespace muduo$/;"	n
muduo	TimeZone.cc	/^namespace muduo$/;"	n
muduo	TimeZone.h	/^namespace muduo$/;"	n
muduo	Timer.h	/^namespace muduo$/;"	n
muduo	TimerId.h	/^namespace muduo$/;"	n
muduo	TimerQueue.cc	/^namespace muduo$/;"	n
muduo	TimerQueue.h	/^namespace muduo$/;"	n
muduo	Timestamp.h	/^namespace muduo$/;"	n
muduo	Types.h	/^namespace muduo$/;"	n
muduo	WeakCallback.h	/^namespace muduo$/;"	n
muduo	ZlibStream.h	/^namespace muduo$/;"	n
muduo	copyable.h	/^namespace muduo$/;"	n
muduo	noncopyable.h	/^namespace muduo$/;"	n
mutex_	AsyncLogging.h	/^  muduo::MutexLock mutex_;$/;"	m	class:muduo::AsyncLogging
mutex_	BlockingQueue.h	/^  mutable MutexLock mutex_;$/;"	m	class:muduo::BlockingQueue
mutex_	BoundedBlockingQueue.h	/^  mutable MutexLock          mutex_;$/;"	m	class:muduo::BoundedBlockingQueue
mutex_	Condition.h	/^  MutexLock& mutex_;$/;"	m	class:muduo::Condition
mutex_	CountDownLatch.h	/^  mutable MutexLock mutex_;$/;"	m	class:muduo::CountDownLatch
mutex_	EventLoop.h	/^				mutable MutexLock mutex_;$/;"	m	class:muduo::net::EventLoop
mutex_	EventLoopThread.h	/^				MutexLock mutex_;$/;"	m	class:muduo::net::EventLoopThread
mutex_	LogFile.h	/^  std::unique_ptr<MutexLock> mutex_;$/;"	m	class:muduo::LogFile
mutex_	Mutex.h	/^  MutexLock& mutex_;$/;"	m	class:muduo::MutexLockGuard
mutex_	TcpClient.h	/^				mutable MutexLock mutex_;$/;"	m	class:muduo::net::TcpClient
mutex_	ThreadPool.h	/^  mutable MutexLock mutex_;$/;"	m	class:muduo::ThreadPool
name	CurrentThread.h	/^		inline const char* name()$/;"	f	namespace:muduo::CurrentThread
name	EventLoopThreadPool.h	/^  const string& name() const$/;"	f	class:muduo::net::EventLoopThreadPool
name	TcpClient.h	/^				const string& name() const$/;"	f	class:muduo::net::TcpClient
name	TcpConnection.h	/^				const string& name() const { return name_; }$/;"	f	class:muduo::net::TcpConnection
name	TcpServer.h	/^				const string& name() const { return name_; }$/;"	f	class:muduo::net::TcpServer
name	Thread.h	/^			const string& name() const { return name_; }$/;"	f	class:muduo::Thread
name	ThreadPool.h	/^  const string& name() const$/;"	f	class:muduo::ThreadPool
name_	EventLoopThreadPool.h	/^  string name_;$/;"	m	class:muduo::net::EventLoopThreadPool
name_	TcpClient.h	/^				const string name_;$/;"	m	class:muduo::net::TcpClient
name_	TcpConnection.h	/^				const string name_;$/;"	m	class:muduo::net::TcpConnection
name_	TcpServer.h	/^				const string name_;$/;"	m	class:muduo::net::TcpServer
name_	Thread.cc	/^			string name_;$/;"	m	struct:muduo::detail::ThreadData
name_	Thread.h	/^			string     name_;$/;"	m	class:muduo::Thread
name_	ThreadPool.h	/^  string name_;$/;"	m	class:muduo::ThreadPool
names	TimeZone.cc	/^  vector<string> names;$/;"	m	struct:TimeZone::Data
net	Acceptor.h	/^	namespace net$/;"	n	namespace:muduo
net	Buffer.h	/^	namespace net$/;"	n	namespace:muduo
net	Callbacks.h	/^namespace net$/;"	n	namespace:muduo
net	Channel.h	/^	namespace net$/;"	n	namespace:muduo
net	Connector.h	/^	namespace net$/;"	n	namespace:muduo
net	EPollPoller.h	/^	namespace net$/;"	n	namespace:muduo
net	Endian.h	/^namespace net$/;"	n	namespace:muduo
net	EventLoop.h	/^	namespace net$/;"	n	namespace:muduo
net	EventLoopThread.h	/^	namespace net$/;"	n	namespace:muduo
net	EventLoopThreadPool.h	/^namespace net$/;"	n	namespace:muduo
net	InetAddress.h	/^	namespace net$/;"	n	namespace:muduo
net	PollPoller.h	/^namespace net$/;"	n	namespace:muduo
net	Poller.h	/^namespace net$/;"	n	namespace:muduo
net	Socket.h	/^	namespace net$/;"	n	namespace:muduo
net	SocketsOps.h	/^	namespace net$/;"	n	namespace:muduo
net	TcpClient.cc	/^	namespace net$/;"	n	namespace:muduo
net	TcpClient.h	/^	namespace net$/;"	n	namespace:muduo
net	TcpConnection.h	/^	namespace net$/;"	n	namespace:muduo
net	TcpServer.h	/^	namespace net$/;"	n	namespace:muduo
net	Timer.h	/^namespace net$/;"	n	namespace:muduo
net	TimerId.h	/^namespace net$/;"	n	namespace:muduo
net	TimerQueue.cc	/^	namespace net$/;"	n	namespace:muduo
net	TimerQueue.h	/^namespace net$/;"	n	namespace:muduo
net	ZlibStream.h	/^namespace net$/;"	n	namespace:muduo
networkToHost16	Endian.h	/^inline uint16_t networkToHost16(uint16_t net16)$/;"	f	namespace:muduo::net::sockets
networkToHost32	Endian.h	/^inline uint32_t networkToHost32(uint32_t net32)$/;"	f	namespace:muduo::net::sockets
networkToHost64	Endian.h	/^inline uint64_t networkToHost64(uint64_t net64)$/;"	f	namespace:muduo::net::sockets
newConnection	TcpClient.cc	/^void TcpClient::newConnection(int sockfd)$/;"	f	class:TcpClient
newConnection	TcpServer.cc	/^void TcpServer::newConnection(int sockfd, const InetAddress& peerAddr)$/;"	f	class:TcpServer
newConnectionCallback_	Acceptor.h	/^				NewConnectionCallback newConnectionCallback_;$/;"	m	class:muduo::net::Acceptor
newConnectionCallback_	Connector.h	/^				NewConnectionCallback newConnectionCallback_;$/;"	m	class:muduo::net::Connector
newDefaultPoller	DefaultPoller.cc	/^Poller* Poller::newDefaultPoller(EventLoop* loop)$/;"	f	class:Poller
nextConnId_	TcpClient.h	/^				int nextConnId_;$/;"	m	class:muduo::net::TcpClient
nextConnId_	TcpServer.h	/^				int nextConnId_;$/;"	m	class:muduo::net::TcpServer
next_	EventLoopThreadPool.h	/^  int next_;$/;"	m	class:muduo::net::EventLoopThreadPool
noncopyable	noncopyable.h	/^class noncopyable$/;"	c	namespace:muduo
notify	Condition.h	/^  void notify()$/;"	f	class:muduo::Condition
notifyAll	Condition.h	/^  void notifyAll()$/;"	f	class:muduo::Condition
now	Timestamp.cc	/^Timestamp Timestamp::now()$/;"	f	class:Timestamp
numCreated	Thread.h	/^			static int numCreated() { return numCreated_.get(); }$/;"	f	class:muduo::Thread
numCreated	Timer.h	/^  static int64_t numCreated() { return s_numCreated_.get(); }$/;"	f	class:muduo::net::Timer
numCreated_	Thread.cc	/^	AtomicInt32 Thread::numCreated_;$/;"	m	class:muduo::Thread
numCreated_	Thread.h	/^			static AtomicInt32 numCreated_;$/;"	m	class:muduo::Thread
numThreads	ProcessInfo.cc	/^int ProcessInfo::numThreads()$/;"	f	class:ProcessInfo
numThreads_	EventLoopThreadPool.h	/^  int numThreads_;$/;"	m	class:muduo::net::EventLoopThreadPool
object_	WeakCallback.h	/^  std::weak_ptr<CLASS> object_;$/;"	m	class:muduo::WeakCallback
offset	GzipFile.h	/^  off_t offset() const { return ::gzoffset(file_); }$/;"	f	class:muduo::GzipFile
openForAppend	GzipFile.h	/^  static GzipFile openForAppend(StringArg filename)$/;"	f	class:muduo::GzipFile
openForRead	GzipFile.h	/^  static GzipFile openForRead(StringArg filename)$/;"	f	class:muduo::GzipFile
openForWriteExclusive	GzipFile.h	/^  static GzipFile openForWriteExclusive(StringArg filename)$/;"	f	class:muduo::GzipFile
openForWriteTruncate	GzipFile.h	/^  static GzipFile openForWriteTruncate(StringArg filename)$/;"	f	class:muduo::GzipFile
openedFiles	ProcessInfo.cc	/^int ProcessInfo::openedFiles()$/;"	f	class:ProcessInfo
operationToString	EPollPoller.cc	/^const char* EPollPoller::operationToString(int op)$/;"	f	class:EPollPoller
operator !=	StringPiece.h	/^			bool operator!=(const StringPiece& x) const {$/;"	f	class:muduo::StringPiece
operator ()	TimeZone.cc	/^  bool operator()(const Transition& lhs, const Transition& rhs) const$/;"	f	struct:muduo::detail::Comp
operator ()	WeakCallback.h	/^  void operator()(ARGS&&... args) const$/;"	f	class:muduo::WeakCallback
operator <	Date.h	/^inline bool operator<(Date x, Date y)$/;"	f	namespace:muduo
operator <	Timestamp.h	/^inline bool operator<(Timestamp lhs, Timestamp rhs)$/;"	f	namespace:muduo
operator <<	LogStream.cc	/^LogStream& LogStream::operator<<(const void* p)$/;"	f	class:LogStream
operator <<	LogStream.cc	/^LogStream& LogStream::operator<<(double v)$/;"	f	class:LogStream
operator <<	LogStream.cc	/^LogStream& LogStream::operator<<(int v)$/;"	f	class:LogStream
operator <<	LogStream.cc	/^LogStream& LogStream::operator<<(long long v)$/;"	f	class:LogStream
operator <<	LogStream.cc	/^LogStream& LogStream::operator<<(long v)$/;"	f	class:LogStream
operator <<	LogStream.cc	/^LogStream& LogStream::operator<<(short v)$/;"	f	class:LogStream
operator <<	LogStream.cc	/^LogStream& LogStream::operator<<(unsigned int v)$/;"	f	class:LogStream
operator <<	LogStream.cc	/^LogStream& LogStream::operator<<(unsigned long long v)$/;"	f	class:LogStream
operator <<	LogStream.cc	/^LogStream& LogStream::operator<<(unsigned long v)$/;"	f	class:LogStream
operator <<	LogStream.cc	/^LogStream& LogStream::operator<<(unsigned short v)$/;"	f	class:LogStream
operator <<	LogStream.h	/^		self& operator<<(bool v)$/;"	f	class:muduo::LogStream
operator <<	LogStream.h	/^		self& operator<<(char v)$/;"	f	class:muduo::LogStream
operator <<	LogStream.h	/^		self& operator<<(const Buffer& v)$/;"	f	class:muduo::LogStream
operator <<	LogStream.h	/^		self& operator<<(const StringPiece& v)$/;"	f	class:muduo::LogStream
operator <<	LogStream.h	/^		self& operator<<(const char* str)$/;"	f	class:muduo::LogStream
operator <<	LogStream.h	/^		self& operator<<(const string& v)$/;"	f	class:muduo::LogStream
operator <<	LogStream.h	/^		self& operator<<(const unsigned char* str)$/;"	f	class:muduo::LogStream
operator <<	LogStream.h	/^		self& operator<<(float v)$/;"	f	class:muduo::LogStream
operator <<	LogStream.h	/^	inline LogStream& operator<<(LogStream& s, const Fmt& fmt)$/;"	f	namespace:muduo
operator <<	Logging.cc	/^	inline LogStream& operator<<(LogStream& s, T v)$/;"	f	namespace:muduo
operator <<	Logging.cc	/^	inline LogStream& operator<<(LogStream& s, const Logger::SourceFile& v)$/;"	f	namespace:muduo
operator ==	Date.h	/^inline bool operator==(Date x, Date y)$/;"	f	namespace:muduo
operator ==	StringPiece.h	/^			bool operator==(const StringPiece& x) const {$/;"	f	class:muduo::StringPiece
operator ==	Timestamp.h	/^inline bool operator==(Timestamp lhs, Timestamp rhs)$/;"	f	namespace:muduo
operator []	StringPiece.h	/^			char operator[](int i) const { return ptr_[i]; }$/;"	f	class:muduo::StringPiece
outputBuffer	TcpConnection.h	/^				Buffer* outputBuffer()$/;"	f	class:muduo::net::TcpConnection
outputBuffer_	TcpConnection.h	/^				Buffer outputBuffer_; \/\/ FIXME: use list<Buffer> as output buffer.$/;"	m	class:muduo::net::TcpConnection
outputBytes	ZlibStream.h	/^  int64_t outputBytes() const { return zstream_.total_out; }$/;"	f	class:muduo::net::ZlibOutputStream
output_	ZlibStream.h	/^  Buffer* output_;$/;"	m	class:muduo::net::ZlibInputStream
output_	ZlibStream.h	/^  Buffer* output_;$/;"	m	class:muduo::net::ZlibOutputStream
override	EPollPoller.h	/^				Timestamp poll(int timeoutMs, ChannelList* activeChannels) override;$/;"	m	class:muduo::net::EPollPoller
override	EPollPoller.h	/^				void removeChannel(Channel* channel) override;$/;"	m	class:muduo::net::EPollPoller
override	EPollPoller.h	/^				void updateChannel(Channel* channel) override;$/;"	m	class:muduo::net::EPollPoller
override	EPollPoller.h	/^				~EPollPoller() override;$/;"	m	class:muduo::net::EPollPoller
override	Exception.h	/^  ~Exception() noexcept override = default;$/;"	m	class:muduo::Exception
override	PollPoller.h	/^  Timestamp poll(int timeoutMs, ChannelList* activeChannels) override;$/;"	m	class:muduo::net::PollPoller
override	PollPoller.h	/^  void removeChannel(Channel* channel) override;$/;"	m	class:muduo::net::PollPoller
override	PollPoller.h	/^  void updateChannel(Channel* channel) override;$/;"	m	class:muduo::net::PollPoller
override	PollPoller.h	/^  ~PollPoller() override;$/;"	m	class:muduo::net::PollPoller
ownerLoop	Channel.h	/^				EventLoop* ownerLoop() { return loop_; }$/;"	f	class:muduo::net::Channel
ownerLoop_	Poller.h	/^  EventLoop* ownerLoop_;$/;"	m	class:muduo::net::Poller
pageSize	ProcessInfo.cc	/^int ProcessInfo::pageSize()$/;"	f	class:ProcessInfo
pcond_	Condition.h	/^  pthread_cond_t pcond_;$/;"	m	class:muduo::Condition
peek	Buffer.h	/^				const char* peek() const$/;"	f	class:muduo::net::Buffer
peekInt16	Buffer.h	/^				int16_t peekInt16() const$/;"	f	class:muduo::net::Buffer
peekInt32	Buffer.h	/^				int32_t peekInt32() const$/;"	f	class:muduo::net::Buffer
peekInt64	Buffer.h	/^				int64_t peekInt64() const$/;"	f	class:muduo::net::Buffer
peekInt8	Buffer.h	/^				int8_t peekInt8() const$/;"	f	class:muduo::net::Buffer
peerAddr_	TcpConnection.h	/^				const InetAddress peerAddr_;$/;"	m	class:muduo::net::TcpConnection
peerAddress	TcpConnection.h	/^				const InetAddress& peerAddress() const { return peerAddr_; }$/;"	f	class:muduo::net::TcpConnection
pid	ProcessInfo.cc	/^pid_t ProcessInfo::pid()$/;"	f	class:ProcessInfo
pidString	ProcessInfo.cc	/^string ProcessInfo::pidString()$/;"	f	class:ProcessInfo
pkey_	ThreadLocal.h	/^  pthread_key_t pkey_;$/;"	m	class:muduo::ThreadLocal
pkey_	ThreadLocalSingleton.h	/^    pthread_key_t pkey_;$/;"	m	class:muduo::ThreadLocalSingleton::Deleter
pointer	ThreadLocalSingleton.h	/^  static T* pointer()$/;"	f	class:muduo::ThreadLocalSingleton
poll	EPollPoller.cc	/^Timestamp EPollPoller::poll(int timeoutMs, ChannelList* activeChannels)$/;"	f	class:EPollPoller
poll	PollPoller.cc	/^Timestamp PollPoller::poll(int timeoutMs, ChannelList* activeChannels)$/;"	f	class:PollPoller
pollReturnTime	EventLoop.h	/^				Timestamp pollReturnTime() const { return pollReturnTime_; }$/;"	f	class:muduo::net::EventLoop
pollReturnTime_	EventLoop.h	/^				Timestamp pollReturnTime_;$/;"	m	class:muduo::net::EventLoop
poller_	EventLoop.h	/^				std::unique_ptr<Poller> poller_;$/;"	m	class:muduo::net::EventLoop
pollfds_	PollPoller.h	/^  PollFdList pollfds_;$/;"	m	class:muduo::net::PollPoller
ponce_	Singleton.h	/^  static pthread_once_t ponce_;$/;"	m	class:muduo::Singleton
ponce_	Singleton.h	/^pthread_once_t Singleton<T>::ponce_ = PTHREAD_ONCE_INIT;$/;"	m	class:muduo::Singleton
portNetEndian	InetAddress.h	/^				uint16_t portNetEndian() const { return addr_.sin_port; }$/;"	f	class:muduo::net::InetAddress
prepend	Buffer.h	/^				void prepend(const void* \/*restrict*\/ data, size_t len)$/;"	f	class:muduo::net::Buffer
prependInt16	Buffer.h	/^				void prependInt16(int16_t x)$/;"	f	class:muduo::net::Buffer
prependInt32	Buffer.h	/^				void prependInt32(int32_t x)$/;"	f	class:muduo::net::Buffer
prependInt64	Buffer.h	/^				void prependInt64(int64_t x)$/;"	f	class:muduo::net::Buffer
prependInt8	Buffer.h	/^				void prependInt8(int8_t x)$/;"	f	class:muduo::net::Buffer
prependableBytes	Buffer.h	/^				size_t prependableBytes() const$/;"	f	class:muduo::net::Buffer
printActiveChannels	EventLoop.cc	/^void EventLoop::printActiveChannels() const$/;"	f	class:EventLoop
procStat	ProcessInfo.cc	/^string ProcessInfo::procStat()$/;"	f	class:ProcessInfo
procStatus	ProcessInfo.cc	/^string ProcessInfo::procStatus()$/;"	f	class:ProcessInfo
procname	ProcessInfo.cc	/^StringPiece ProcessInfo::procname(const string& stat)$/;"	f	class:ProcessInfo
procname	ProcessInfo.cc	/^string ProcessInfo::procname()$/;"	f	class:ProcessInfo
pthreadId_	Thread.h	/^			pthread_t  pthreadId_;$/;"	m	class:muduo::Thread
ptr_	StringPiece.h	/^			const char*   ptr_;$/;"	m	class:muduo::StringPiece
put	BlockingQueue.h	/^  void put(T&& x)$/;"	f	class:muduo::BlockingQueue
put	BlockingQueue.h	/^  void put(const T& x)$/;"	f	class:muduo::BlockingQueue
put	BoundedBlockingQueue.h	/^  void put(T&& x)$/;"	f	class:muduo::BoundedBlockingQueue
put	BoundedBlockingQueue.h	/^  void put(const T& x)$/;"	f	class:muduo::BoundedBlockingQueue
queueInLoop	EventLoop.cc	/^void EventLoop::queueInLoop(Functor cb)$/;"	f	class:EventLoop
queueSize	EventLoop.cc	/^size_t EventLoop::queueSize() const$/;"	f	class:EventLoop
queueSize	ThreadPool.cc	/^size_t ThreadPool::queueSize() const$/;"	f	class:ThreadPool
quit	EventLoop.cc	/^void EventLoop::quit()$/;"	f	class:EventLoop
quit_	EventLoop.h	/^				std::atomic<bool> quit_;$/;"	m	class:muduo::net::EventLoop
read	GzipFile.h	/^  int read(void* buf, int len) { return ::gzread(file_, buf, len); }$/;"	f	class:muduo::GzipFile
read	SocketsOps.cc	/^ssize_t sockets::read(int sockfd, void *buf, size_t count)$/;"	f	class:sockets
readBytes	TimeZone.cc	/^  string readBytes(int n)$/;"	f	class:muduo::detail::File
readCallback_	Channel.h	/^				ReadEventCallback readCallback_;$/;"	m	class:muduo::net::Channel
readFd	Buffer.cc	/^ssize_t Buffer::readFd(int fd, int* savedErrno)$/;"	f	class:Buffer
readFile	FileUtil.h	/^int readFile(StringArg filename,$/;"	f	namespace:muduo::FileUtil
readInt16	Buffer.h	/^				int16_t readInt16()$/;"	f	class:muduo::net::Buffer
readInt32	Buffer.h	/^				int32_t readInt32()$/;"	f	class:muduo::net::Buffer
readInt32	TimeZone.cc	/^  int32_t readInt32()$/;"	f	class:muduo::detail::File
readInt64	Buffer.h	/^				int64_t readInt64()$/;"	f	class:muduo::net::Buffer
readInt8	Buffer.h	/^				int8_t readInt8()$/;"	f	class:muduo::net::Buffer
readTimeZoneFile	TimeZone.cc	/^bool readTimeZoneFile(const char* zonefile, struct TimeZone::Data* data)$/;"	f	namespace:muduo::detail
readTimerfd	TimerQueue.cc	/^			void readTimerfd(int timerfd, Timestamp now)$/;"	f	namespace:muduo::net::detail
readToBuffer	FileUtil.cc	/^int FileUtil::ReadSmallFile::readToBuffer(int* size)$/;"	f	class:FileUtil::ReadSmallFile
readToString	FileUtil.cc	/^int FileUtil::ReadSmallFile::readToString(int maxSize,$/;"	f	class:FileUtil::ReadSmallFile
readUInt8	TimeZone.cc	/^  uint8_t readUInt8()$/;"	f	class:muduo::detail::File
readableBytes	Buffer.h	/^				size_t readableBytes() const$/;"	f	class:muduo::net::Buffer
readerIndex_	Buffer.h	/^				size_t readerIndex_;$/;"	m	class:muduo::net::Buffer
reading_	TcpConnection.h	/^				bool reading_;$/;"	m	class:muduo::net::TcpConnection
readv	SocketsOps.cc	/^ssize_t sockets::readv(int sockfd, const struct iovec *iov, int iovcnt)$/;"	f	class:sockets
remove	Channel.cc	/^void Channel::remove()$/;"	f	class:Channel
removeAndResetChannel	Connector.cc	/^int Connector::removeAndResetChannel()$/;"	f	class:Connector
removeChannel	EPollPoller.cc	/^void EPollPoller::removeChannel(Channel* channel)$/;"	f	class:EPollPoller
removeChannel	EventLoop.cc	/^void EventLoop::removeChannel(Channel* channel)$/;"	f	class:EventLoop
removeChannel	PollPoller.cc	/^void PollPoller::removeChannel(Channel* channel)$/;"	f	class:PollPoller
removeConnection	TcpClient.cc	/^			void removeConnection(EventLoop* loop, const TcpConnectionPtr& conn)$/;"	f	namespace:muduo::net::detail
removeConnection	TcpClient.cc	/^void TcpClient::removeConnection(const TcpConnectionPtr& conn)$/;"	f	class:TcpClient
removeConnection	TcpServer.cc	/^void TcpServer::removeConnection(const TcpConnectionPtr& conn)$/;"	f	class:TcpServer
removeConnectionInLoop	TcpServer.cc	/^void TcpServer::removeConnectionInLoop(const TcpConnectionPtr& conn)$/;"	f	class:TcpServer
removeConnector	TcpClient.cc	/^			void removeConnector(const ConnectorPtr& connector)$/;"	f	namespace:muduo::net::detail
remove_prefix	StringPiece.h	/^			void remove_prefix(int n) {$/;"	f	class:muduo::StringPiece
remove_suffix	StringPiece.h	/^			void remove_suffix(int n) {$/;"	f	class:muduo::StringPiece
repeat	Timer.h	/^  bool repeat() const { return repeat_; }$/;"	f	class:muduo::net::Timer
repeat_	Timer.h	/^  const bool repeat_;$/;"	m	class:muduo::net::Timer
require_32_bit_integer_at_least	Date.cc	/^char require_32_bit_integer_at_least[sizeof(int) >= sizeof(int32_t) ? 1 : -1];$/;"	m	namespace:muduo::detail
reset	LogStream.h	/^				void reset() { cur_ = data_; }$/;"	f	class:muduo::detail::FixedBuffer
reset	TimerQueue.cc	/^void TimerQueue::reset(const std::vector<Entry>& expired, Timestamp now)$/;"	f	class:TimerQueue
resetBuffer	LogStream.h	/^		void resetBuffer() { buffer_.reset(); }$/;"	f	class:muduo::LogStream
resetChannel	Connector.cc	/^void Connector::resetChannel()$/;"	f	class:Connector
resetTimerfd	TimerQueue.cc	/^			void resetTimerfd(int timerfd, Timestamp expiration)$/;"	f	namespace:muduo::net::detail
resolve	InetAddress.cc	/^bool InetAddress::resolve(StringArg hostname, InetAddress* out)$/;"	f	class:InetAddress
restart	Connector.cc	/^void Connector::restart()$/;"	f	class:Connector
restart	Timer.cc	/^void Timer::restart(Timestamp now)$/;"	f	class:Timer
retrieve	Buffer.h	/^				void retrieve(size_t len)$/;"	f	class:muduo::net::Buffer
retrieveAll	Buffer.h	/^				void retrieveAll()$/;"	f	class:muduo::net::Buffer
retrieveAllAsString	Buffer.h	/^				string retrieveAllAsString()$/;"	f	class:muduo::net::Buffer
retrieveAsString	Buffer.h	/^				string retrieveAsString(size_t len)$/;"	f	class:muduo::net::Buffer
retrieveInt16	Buffer.h	/^				void retrieveInt16()$/;"	f	class:muduo::net::Buffer
retrieveInt32	Buffer.h	/^				void retrieveInt32()$/;"	f	class:muduo::net::Buffer
retrieveInt64	Buffer.h	/^				void retrieveInt64()$/;"	f	class:muduo::net::Buffer
retrieveInt8	Buffer.h	/^				void retrieveInt8()$/;"	f	class:muduo::net::Buffer
retrieveUntil	Buffer.h	/^				void retrieveUntil(const char* end)$/;"	f	class:muduo::net::Buffer
retry	Connector.cc	/^void Connector::retry(int sockfd)$/;"	f	class:Connector
retry	TcpClient.h	/^				bool retry() const { return retry_; }$/;"	f	class:muduo::net::TcpClient
retryDelayMs_	Connector.h	/^				int retryDelayMs_;$/;"	m	class:muduo::net::Connector
retry_	TcpClient.h	/^				bool retry_;   \/\/ atomic$/;"	m	class:muduo::net::TcpClient
reventsToString	Channel.cc	/^string Channel::reventsToString() const$/;"	f	class:Channel
revents_	Channel.h	/^				int        revents_; \/\/ it's the received event types of epoll or poll$/;"	m	class:muduo::net::Channel
rollFile	LogFile.cc	/^bool LogFile::rollFile()$/;"	f	class:LogFile
rollSize_	AsyncLogging.h	/^  const off_t rollSize_;$/;"	m	class:muduo::AsyncLogging
rollSize_	LogFile.h	/^  const off_t rollSize_;$/;"	m	class:muduo::LogFile
run	ThreadPool.cc	/^void ThreadPool::run(Task task)$/;"	f	class:ThreadPool
run	Timer.h	/^  void run() const$/;"	f	class:muduo::net::Timer
runAfter	EventLoop.cc	/^TimerId EventLoop::runAfter(double delay, TimerCallback cb)$/;"	f	class:EventLoop
runAt	EventLoop.cc	/^TimerId EventLoop::runAt(Timestamp time, TimerCallback cb)$/;"	f	class:EventLoop
runEvery	EventLoop.cc	/^TimerId EventLoop::runEvery(double interval, TimerCallback cb)$/;"	f	class:EventLoop
runInLoop	EventLoop.cc	/^void EventLoop::runInLoop(Functor cb)$/;"	f	class:EventLoop
runInThread	Thread.cc	/^			void runInThread()$/;"	f	struct:muduo::detail::ThreadData
runInThread	ThreadPool.cc	/^void ThreadPool::runInThread()$/;"	f	class:ThreadPool
running_	AsyncLogging.h	/^  std::atomic<bool> running_;$/;"	m	class:muduo::AsyncLogging
running_	ThreadPool.h	/^  bool running_;$/;"	m	class:muduo::ThreadPool
s_numCreated_	Timer.h	/^  static AtomicInt64 s_numCreated_;$/;"	m	class:muduo::net::Timer
scanDir	ProcessInfo.cc	/^int scanDir(const char *dirpath, int (*filter)(const struct dirent *))$/;"	f	namespace:muduo::detail
secondsSinceEpoch	Timestamp.h	/^  time_t secondsSinceEpoch() const$/;"	f	class:muduo::Timestamp
self	LogStream.h	/^		typedef LogStream self;$/;"	t	class:muduo::LogStream
send	TcpConnection.cc	/^void TcpConnection::send(Buffer* buf)$/;"	f	class:TcpConnection
send	TcpConnection.cc	/^void TcpConnection::send(const StringPiece& message)$/;"	f	class:TcpConnection
send	TcpConnection.cc	/^void TcpConnection::send(const void* data, int len)$/;"	f	class:TcpConnection
sendInLoop	TcpConnection.cc	/^void TcpConnection::sendInLoop(const StringPiece& message)$/;"	f	class:TcpConnection
sendInLoop	TcpConnection.cc	/^void TcpConnection::sendInLoop(const void* data, size_t len)$/;"	f	class:TcpConnection
sequence	Timer.h	/^  int64_t sequence() const { return sequence_; }$/;"	f	class:muduo::net::Timer
sequence_	Timer.h	/^  const int64_t sequence_;$/;"	m	class:muduo::net::Timer
sequence_	TimerId.h	/^  int64_t sequence_;$/;"	m	class:muduo::net::TimerId
serverAddr_	Connector.h	/^				InetAddress serverAddr_;$/;"	m	class:muduo::net::Connector
serverAddress	Connector.h	/^				const InetAddress& serverAddress() const { return serverAddr_; }$/;"	f	class:muduo::net::Connector
set	StringPiece.h	/^			void set(const char* buffer, int len) { ptr_ = buffer; length_ = len; }$/;"	f	class:muduo::StringPiece
set	StringPiece.h	/^			void set(const char* str) {$/;"	f	class:muduo::StringPiece
set	StringPiece.h	/^			void set(const void* buffer, int len) {$/;"	f	class:muduo::StringPiece
set	ThreadLocalSingleton.h	/^    void set(T* newObj)$/;"	f	class:muduo::ThreadLocalSingleton::Deleter
setBuffer	GzipFile.h	/^  bool setBuffer(int size) { return ::gzbuffer(file_, size) == 0; }$/;"	f	class:muduo::GzipFile
setCloseCallback	Channel.h	/^				void setCloseCallback(EventCallback cb)$/;"	f	class:muduo::net::Channel
setCloseCallback	TcpConnection.h	/^				void setCloseCallback(const CloseCallback& cb)$/;"	f	class:muduo::net::TcpConnection
setConnectionCallback	TcpClient.h	/^				void setConnectionCallback(ConnectionCallback cb)$/;"	f	class:muduo::net::TcpClient
setConnectionCallback	TcpConnection.h	/^				void setConnectionCallback(const ConnectionCallback& cb)$/;"	f	class:muduo::net::TcpConnection
setConnectionCallback	TcpServer.h	/^				void setConnectionCallback(const ConnectionCallback& cb)$/;"	f	class:muduo::net::TcpServer
setCookie	LogStream.h	/^				void setCookie(void (*cookie)()) { cookie_ = cookie; }$/;"	f	class:muduo::detail::FixedBuffer
setDefaultName	Thread.cc	/^	void Thread::setDefaultName()$/;"	f	class:muduo::Thread
setErrorCallback	Channel.h	/^				void setErrorCallback(EventCallback cb)$/;"	f	class:muduo::net::Channel
setFlush	Logging.cc	/^void Logger::setFlush(FlushFunc flush)$/;"	f	class:Logger
setHighWaterMarkCallback	TcpConnection.h	/^				void setHighWaterMarkCallback(const HighWaterMarkCallback& cb, size_t highWaterMark)$/;"	f	class:muduo::net::TcpConnection
setKeepAlive	Socket.cc	/^void Socket::setKeepAlive(bool on)$/;"	f	class:Socket
setLogLevel	Logging.cc	/^void Logger::setLogLevel(Logger::LogLevel level)$/;"	f	class:Logger
setMaxQueueSize	ThreadPool.h	/^  void setMaxQueueSize(int maxSize) { maxQueueSize_ = maxSize; }$/;"	f	class:muduo::ThreadPool
setMessageCallback	TcpClient.h	/^				void setMessageCallback(MessageCallback cb)$/;"	f	class:muduo::net::TcpClient
setMessageCallback	TcpConnection.h	/^				void setMessageCallback(const MessageCallback& cb)$/;"	f	class:muduo::net::TcpConnection
setMessageCallback	TcpServer.h	/^				void setMessageCallback(const MessageCallback& cb)$/;"	f	class:muduo::net::TcpServer
setNewConnectionCallback	Acceptor.h	/^				void setNewConnectionCallback(const NewConnectionCallback& cb)$/;"	f	class:muduo::net::Acceptor
setNewConnectionCallback	Connector.h	/^				void setNewConnectionCallback(const NewConnectionCallback& cb)$/;"	f	class:muduo::net::Connector
setNonBlockAndCloseOnExec	SocketsOps.cc	/^	void setNonBlockAndCloseOnExec(int sockfd)$/;"	f	namespace:__anon1
setOutput	Logging.cc	/^void Logger::setOutput(OutputFunc out)$/;"	f	class:Logger
setReadCallback	Channel.h	/^				void setReadCallback(ReadEventCallback cb)$/;"	f	class:muduo::net::Channel
setReuseAddr	Socket.cc	/^void Socket::setReuseAddr(bool on)$/;"	f	class:Socket
setReusePort	Socket.cc	/^void Socket::setReusePort(bool on)$/;"	f	class:Socket
setScopeId	InetAddress.cc	/^void InetAddress::setScopeId(uint32_t scope_id)$/;"	f	class:InetAddress
setSockAddrInet6	InetAddress.h	/^				void setSockAddrInet6(const struct sockaddr_in6& addr6) { addr6_ = addr6; }$/;"	f	class:muduo::net::InetAddress
setState	Connector.h	/^				void setState(States s) { state_ = s; }$/;"	f	class:muduo::net::Connector
setState	TcpConnection.h	/^				void setState(StateE s) { state_ = s; }$/;"	f	class:muduo::net::TcpConnection
setTcpNoDelay	Socket.cc	/^void Socket::setTcpNoDelay(bool on)$/;"	f	class:Socket
setTcpNoDelay	TcpConnection.cc	/^void TcpConnection::setTcpNoDelay(bool on)$/;"	f	class:TcpConnection
setThreadInitCallback	TcpServer.h	/^				void setThreadInitCallback(const ThreadInitCallback& cb)$/;"	f	class:muduo::net::TcpServer
setThreadInitCallback	ThreadPool.h	/^  void setThreadInitCallback(const Task& cb)$/;"	f	class:muduo::ThreadPool
setThreadNum	EventLoopThreadPool.h	/^  void setThreadNum(int numThreads) { numThreads_ = numThreads; }$/;"	f	class:muduo::net::EventLoopThreadPool
setThreadNum	TcpServer.cc	/^void TcpServer::setThreadNum(int numThreads)$/;"	f	class:TcpServer
setTimeZone	Logging.cc	/^void Logger::setTimeZone(const TimeZone& tz)$/;"	f	class:Logger
setWriteCallback	Channel.h	/^				void setWriteCallback(EventCallback cb)$/;"	f	class:muduo::net::Channel
setWriteCompleteCallback	TcpClient.h	/^				void setWriteCompleteCallback(WriteCompleteCallback cb)$/;"	f	class:muduo::net::TcpClient
setWriteCompleteCallback	TcpConnection.h	/^				void setWriteCompleteCallback(const WriteCompleteCallback& cb)$/;"	f	class:muduo::net::TcpConnection
setWriteCompleteCallback	TcpServer.h	/^				void setWriteCompleteCallback(const WriteCompleteCallback& cb)$/;"	f	class:muduo::net::TcpServer
set_index	Channel.h	/^				void set_index(int idx) { index_ = idx; }$/;"	f	class:muduo::net::Channel
set_revents	Channel.h	/^				void set_revents(int revt) { revents_ = revt; } \/\/ used by pollers$/;"	f	class:muduo::net::Channel
shrink	Buffer.h	/^				void shrink(size_t reserve)$/;"	f	class:muduo::net::Buffer
shutdown	TcpConnection.cc	/^void TcpConnection::shutdown()$/;"	f	class:TcpConnection
shutdownInLoop	TcpConnection.cc	/^void TcpConnection::shutdownInLoop()$/;"	f	class:TcpConnection
shutdownWrite	Socket.cc	/^void Socket::shutdownWrite()$/;"	f	class:Socket
shutdownWrite	SocketsOps.cc	/^void sockets::shutdownWrite(int sockfd)$/;"	f	class:sockets
size	BlockingQueue.h	/^  size_t size() const$/;"	f	class:muduo::BlockingQueue
size	BoundedBlockingQueue.h	/^  size_t size() const$/;"	f	class:muduo::BoundedBlockingQueue
size	StringPiece.h	/^			int size() const { return length_; }$/;"	f	class:muduo::StringPiece
size_	Logging.h	/^					int size_;$/;"	m	class:muduo::Logger::SourceFile
sleepUsec	Thread.cc	/^	void CurrentThread::sleepUsec(int64_t usec)$/;"	f	class:muduo::CurrentThread
sockaddr_cast	SocketsOps.cc	/^const struct sockaddr* sockets::sockaddr_cast(const struct sockaddr_in* addr)$/;"	f	class:sockets
sockaddr_cast	SocketsOps.cc	/^const struct sockaddr* sockets::sockaddr_cast(const struct sockaddr_in6* addr)$/;"	f	class:sockets
sockaddr_cast	SocketsOps.cc	/^struct sockaddr* sockets::sockaddr_cast(struct sockaddr_in6* addr)$/;"	f	class:sockets
sockaddr_in6_cast	SocketsOps.cc	/^const struct sockaddr_in6* sockets::sockaddr_in6_cast(const struct sockaddr* addr)$/;"	f	class:sockets
sockaddr_in_cast	SocketsOps.cc	/^const struct sockaddr_in* sockets::sockaddr_in_cast(const struct sockaddr* addr)$/;"	f	class:sockets
socket_	TcpConnection.h	/^				std::unique_ptr<Socket> socket_;$/;"	m	class:muduo::net::TcpConnection
sockets	Endian.h	/^namespace sockets$/;"	n	namespace:muduo::net
sockets	InetAddress.h	/^		namespace sockets$/;"	n	namespace:muduo::net
sockets	SocketsOps.h	/^		namespace sockets$/;"	n	namespace:muduo::net
sockfd_	Socket.h	/^				const int sockfd_;$/;"	m	class:muduo::net::Socket
stackTrace	CurrentThread.cc	/^string stackTrace(bool demangle)$/;"	f	namespace:muduo::CurrentThread
stack_	Exception.h	/^  string stack_;$/;"	m	class:muduo::Exception
start	AsyncLogging.h	/^  void start()$/;"	f	class:muduo::AsyncLogging
start	Connector.cc	/^void Connector::start()$/;"	f	class:Connector
start	EventLoopThreadPool.cc	/^void EventLoopThreadPool::start(const ThreadInitCallback& cb)$/;"	f	class:EventLoopThreadPool
start	TcpServer.cc	/^void TcpServer::start()$/;"	f	class:TcpServer
start	Thread.cc	/^	void Thread::start()$/;"	f	class:muduo::Thread
start	ThreadPool.cc	/^void ThreadPool::start(int numThreads)$/;"	f	class:ThreadPool
startInLoop	Connector.cc	/^void Connector::startInLoop()$/;"	f	class:Connector
startLoop	EventLoopThread.cc	/^EventLoop* EventLoopThread::startLoop()$/;"	f	class:EventLoopThread
startOfPeriod_	LogFile.h	/^  time_t startOfPeriod_;$/;"	m	class:muduo::LogFile
startRead	TcpConnection.cc	/^void TcpConnection::startRead()$/;"	f	class:TcpConnection
startReadInLoop	TcpConnection.cc	/^void TcpConnection::startReadInLoop()$/;"	f	class:TcpConnection
startThread	Thread.cc	/^		void* startThread(void* obj)$/;"	f	namespace:muduo::detail
startTime	ProcessInfo.cc	/^Timestamp ProcessInfo::startTime()$/;"	f	class:ProcessInfo
started	EventLoopThreadPool.h	/^  bool started() const$/;"	f	class:muduo::net::EventLoopThreadPool
started	Thread.h	/^			bool started() const { return started_; }$/;"	f	class:muduo::Thread
started_	EventLoopThreadPool.h	/^  bool started_;$/;"	m	class:muduo::net::EventLoopThreadPool
started_	TcpServer.h	/^				AtomicInt32 started_;$/;"	m	class:muduo::net::TcpServer
started_	Thread.h	/^			bool       started_;$/;"	m	class:muduo::Thread
starts_with	StringPiece.h	/^			bool starts_with(const StringPiece& x) const {$/;"	f	class:muduo::StringPiece
stateToString	TcpConnection.cc	/^const char* TcpConnection::stateToString() const$/;"	f	class:TcpConnection
state_	Connector.h	/^				States state_;  \/\/ FIXME: use atomic variable$/;"	m	class:muduo::net::Connector
state_	TcpConnection.h	/^				StateE state_;  \/\/ FIXME: use atomic variable$/;"	m	class:muduo::net::TcpConnection
staticCheck	LogStream.cc	/^void LogStream::staticCheck()$/;"	f	class:LogStream
stop	Connector.cc	/^void Connector::stop()$/;"	f	class:Connector
stop	TcpClient.cc	/^void TcpClient::stop()$/;"	f	class:TcpClient
stop	ThreadPool.cc	/^void ThreadPool::stop()$/;"	f	class:ThreadPool
stopInLoop	Connector.cc	/^void Connector::stopInLoop()$/;"	f	class:Connector
stopRead	TcpConnection.cc	/^void TcpConnection::stopRead()$/;"	f	class:TcpConnection
stopReadInLoop	TcpConnection.cc	/^void TcpConnection::stopReadInLoop()$/;"	f	class:TcpConnection
str_	Logging.cc	/^			const char* str_;$/;"	m	class:muduo::T
str_	StringPiece.h	/^			const char* str_;$/;"	m	class:muduo::StringArg
stream	Logging.h	/^			LogStream& stream() { return impl_.stream_; }$/;"	f	class:muduo::Logger
stream_	Logging.h	/^					LogStream stream_;$/;"	m	class:muduo::Logger::Impl
strerror_tl	Logging.cc	/^	const char* strerror_tl(int savedErrno)$/;"	f	namespace:muduo
swap	Buffer.h	/^				void swap(Buffer& rhs)$/;"	f	class:muduo::net::Buffer
swap	Date.h	/^  void swap(Date& that)$/;"	f	class:muduo::Date
swap	GzipFile.h	/^  void swap(GzipFile& rhs) { std::swap(file_, rhs.file_); }$/;"	f	class:muduo::GzipFile
swap	Timestamp.h	/^  void swap(Timestamp& that)$/;"	f	class:muduo::Timestamp
systemSeconds	ProcessInfo.h	/^    double systemSeconds;$/;"	m	struct:muduo::ProcessInfo::CpuTime
t_cachedTid	CurrentThread.cc	/^__thread int t_cachedTid = 0;$/;"	m	namespace:muduo::CurrentThread
t_errnobuf	Logging.cc	/^	__thread char t_errnobuf[512];$/;"	m	namespace:muduo
t_lastSecond	Logging.cc	/^	__thread time_t t_lastSecond;$/;"	m	namespace:muduo
t_loopInThisThread	EventLoop.cc	/^	__thread EventLoop* t_loopInThisThread = 0;$/;"	m	namespace:__anon2
t_numOpenedFiles	ProcessInfo.cc	/^__thread int t_numOpenedFiles = 0;$/;"	m	namespace:muduo::detail
t_pids	ProcessInfo.cc	/^__thread std::vector<pid_t>* t_pids = NULL;$/;"	m	namespace:muduo::detail
t_resolveBuffer	InetAddress.cc	/^static __thread char t_resolveBuffer[64 * 1024];$/;"	v
t_threadName	CurrentThread.cc	/^__thread const char* t_threadName = "unknown";$/;"	m	namespace:muduo::CurrentThread
t_tidString	CurrentThread.cc	/^__thread char t_tidString[32];$/;"	m	namespace:muduo::CurrentThread
t_tidStringLength	CurrentThread.cc	/^__thread int t_tidStringLength = 6;$/;"	m	namespace:muduo::CurrentThread
t_time	Logging.cc	/^	__thread char t_time[64];$/;"	m	namespace:muduo
t_value_	ThreadLocalSingleton.h	/^  static __thread T* t_value_;$/;"	m	class:muduo::ThreadLocalSingleton
t_value_	ThreadLocalSingleton.h	/^__thread T* ThreadLocalSingleton<T>::t_value_ = 0;$/;"	m	class:muduo::ThreadLocalSingleton
take	BlockingQueue.h	/^  T take()$/;"	f	class:muduo::BlockingQueue
take	BoundedBlockingQueue.h	/^  T take()$/;"	f	class:muduo::BoundedBlockingQueue
take	ThreadPool.cc	/^ThreadPool::Task ThreadPool::take()$/;"	f	class:ThreadPool
taskDirFilter	ProcessInfo.cc	/^int taskDirFilter(const struct dirent* d)$/;"	f	namespace:muduo::detail
tell	GzipFile.h	/^  off_t tell() const { return ::gztell(file_); }$/;"	f	class:muduo::GzipFile
threadFunc	AsyncLogging.cc	/^void AsyncLogging::threadFunc()$/;"	f	class:AsyncLogging
threadFunc	EventLoopThread.cc	/^void EventLoopThread::threadFunc()$/;"	f	class:EventLoopThread
threadId_	EventLoop.h	/^				const pid_t threadId_;$/;"	m	class:muduo::net::EventLoop
threadInitCallback_	TcpServer.h	/^				ThreadInitCallback threadInitCallback_;$/;"	m	class:muduo::net::TcpServer
threadInitCallback_	ThreadPool.h	/^  Task threadInitCallback_;$/;"	m	class:muduo::ThreadPool
threadPool	TcpServer.h	/^				std::shared_ptr<EventLoopThreadPool> threadPool()$/;"	f	class:muduo::net::TcpServer
threadPool_	TcpServer.h	/^				std::shared_ptr<EventLoopThreadPool> threadPool_;$/;"	m	class:muduo::net::TcpServer
threadStat	ProcessInfo.cc	/^string ProcessInfo::threadStat()$/;"	f	class:ProcessInfo
thread_	AsyncLogging.h	/^  muduo::Thread thread_;$/;"	m	class:muduo::AsyncLogging
thread_	EventLoopThread.h	/^				Thread thread_;$/;"	m	class:muduo::net::EventLoopThread
threads	ProcessInfo.cc	/^std::vector<pid_t> ProcessInfo::threads()$/;"	f	class:ProcessInfo
threads_	EventLoopThreadPool.h	/^  std::vector<std::unique_ptr<EventLoopThread>> threads_;$/;"	m	class:muduo::net::EventLoopThreadPool
threads_	ThreadPool.h	/^  std::vector<std::unique_ptr<muduo::Thread>> threads_;$/;"	m	class:muduo::ThreadPool
tid	CurrentThread.h	/^		inline int tid()$/;"	f	namespace:muduo::CurrentThread
tid	Thread.h	/^			pid_t tid() const { return tid_; }$/;"	f	class:muduo::Thread
tidString	CurrentThread.h	/^		inline const char* tidString() \/\/ for logging$/;"	f	namespace:muduo::CurrentThread
tidStringLength	CurrentThread.h	/^		inline int tidStringLength() \/\/ for logging$/;"	f	namespace:muduo::CurrentThread
tid_	Thread.cc	/^			pid_t* tid_;$/;"	m	struct:muduo::detail::ThreadData
tid_	Thread.h	/^			pid_t      tid_;$/;"	m	class:muduo::Thread
tie	Channel.cc	/^void Channel::tie(const std::shared_ptr<void>& obj)$/;"	f	class:Channel
tie_	Channel.h	/^				std::weak_ptr<void> tie_;$/;"	m	class:muduo::net::Channel
tied_	Channel.h	/^				bool tied_;$/;"	m	class:muduo::net::Channel
timeDifference	Timestamp.h	/^inline double timeDifference(Timestamp high, Timestamp low)$/;"	f	namespace:muduo
time_	Logging.h	/^					Timestamp time_;$/;"	m	class:muduo::Logger::Impl
timerQueue_	EventLoop.h	/^				std::unique_ptr<TimerQueue> timerQueue_;$/;"	m	class:muduo::net::EventLoop
timer_	TimerId.h	/^  Timer* timer_;$/;"	m	class:muduo::net::TimerId
timerfdChannel_	TimerQueue.h	/^  Channel timerfdChannel_;$/;"	m	class:muduo::net::TimerQueue
timerfd_	TimerQueue.h	/^  const int timerfd_;$/;"	m	class:muduo::net::TimerQueue
timers_	TimerQueue.h	/^  TimerList timers_;$/;"	m	class:muduo::net::TimerQueue
toFormattedString	Timestamp.cc	/^string Timestamp::toFormattedString(bool showMicroseconds) const$/;"	f	class:Timestamp
toIp	InetAddress.cc	/^string InetAddress::toIp() const$/;"	f	class:InetAddress
toIp	SocketsOps.cc	/^void sockets::toIp(char* buf, size_t size,$/;"	f	class:sockets
toIpPort	InetAddress.cc	/^string InetAddress::toIpPort() const$/;"	f	class:InetAddress
toIpPort	SocketsOps.cc	/^void sockets::toIpPort(char* buf, size_t size,$/;"	f	class:sockets
toIsoString	Date.cc	/^string Date::toIsoString() const$/;"	f	class:Date
toLocalTime	TimeZone.cc	/^struct tm TimeZone::toLocalTime(time_t seconds) const$/;"	f	class:TimeZone
toPort	InetAddress.cc	/^uint16_t InetAddress::toPort() const$/;"	f	class:InetAddress
toString	LogStream.h	/^				string toString() const { return string(data_, length()); }$/;"	f	class:muduo::detail::FixedBuffer
toString	Timestamp.cc	/^string Timestamp::toString() const$/;"	f	class:Timestamp
toStringPiece	Buffer.h	/^				StringPiece toStringPiece() const$/;"	f	class:muduo::net::Buffer
toStringPiece	LogStream.h	/^				StringPiece toStringPiece() const { return StringPiece(data_, length()); }$/;"	f	class:muduo::detail::FixedBuffer
toUtcTime	TimeZone.cc	/^struct tm TimeZone::toUtcTime(time_t secondsSinceEpoch, bool yday)$/;"	f	class:TimeZone
total	ProcessInfo.h	/^    double total() const { return userSeconds + systemSeconds; }$/;"	f	struct:muduo::ProcessInfo::CpuTime
transitions	TimeZone.cc	/^  vector<detail::Transition> transitions;$/;"	m	struct:TimeZone::Data
uid	ProcessInfo.cc	/^uid_t ProcessInfo::uid()$/;"	f	class:ProcessInfo
unwrite	Buffer.h	/^				void unwrite(size_t len)$/;"	f	class:muduo::net::Buffer
update	Channel.cc	/^void Channel::update()$/;"	f	class:Channel
update	EPollPoller.cc	/^void EPollPoller::update(int operation, Channel* channel)$/;"	f	class:EPollPoller
updateChannel	EPollPoller.cc	/^void EPollPoller::updateChannel(Channel* channel)$/;"	f	class:EPollPoller
updateChannel	EventLoop.cc	/^void EventLoop::updateChannel(Channel* channel)$/;"	f	class:EventLoop
updateChannel	PollPoller.cc	/^void PollPoller::updateChannel(Channel* channel)$/;"	f	class:PollPoller
userSeconds	ProcessInfo.h	/^    double userSeconds;$/;"	m	struct:muduo::ProcessInfo::CpuTime
username	ProcessInfo.cc	/^string ProcessInfo::username()$/;"	f	class:ProcessInfo
valid	Date.h	/^  bool valid() const { return julianDayNumber_ > 0; }$/;"	f	class:muduo::Date
valid	GzipFile.h	/^  bool valid() const { return file_ != NULL; }$/;"	f	class:muduo::GzipFile
valid	TimeZone.cc	/^  bool valid() const { return fp_; }$/;"	f	class:muduo::detail::File
valid	TimeZone.h	/^  bool valid() const$/;"	f	class:muduo::TimeZone
valid	Timestamp.h	/^  bool valid() const { return microSecondsSinceEpoch_ > 0; }$/;"	f	class:muduo::Timestamp
value	Singleton.h	/^  const static bool value = sizeof(test<T>(0)) == 1;$/;"	m	struct:muduo::detail::has_no_destroy
value	ThreadLocal.h	/^  T& value()$/;"	f	class:muduo::ThreadLocal
value_	Atomic.h	/^  volatile T value_;$/;"	m	class:muduo::detail::AtomicIntegerT
value_	Singleton.h	/^  static T*             value_;$/;"	m	class:muduo::Singleton
value_	Singleton.h	/^T* Singleton<T>::value_ = NULL;$/;"	m	class:muduo::Singleton
wait	Condition.h	/^  void wait()$/;"	f	class:muduo::Condition
wait	CountDownLatch.cc	/^void CountDownLatch::wait()$/;"	f	class:CountDownLatch
waitForSeconds	Condition.cc	/^bool muduo::Condition::waitForSeconds(double seconds)$/;"	f	class:muduo::Condition
wakeup	EventLoop.cc	/^void EventLoop::wakeup()$/;"	f	class:EventLoop
wakeupChannel_	EventLoop.h	/^				std::unique_ptr<Channel> wakeupChannel_;$/;"	m	class:muduo::net::EventLoop
wakeupFd_	EventLoop.h	/^				int wakeupFd_;$/;"	m	class:muduo::net::EventLoop
weekDay	Date.h	/^  int weekDay() const$/;"	f	class:muduo::Date
writableBytes	Buffer.h	/^				size_t writableBytes() const$/;"	f	class:muduo::net::Buffer
write	FileUtil.cc	/^size_t FileUtil::AppendFile::write(const char* logline, size_t len)$/;"	f	class:FileUtil::AppendFile
write	GzipFile.h	/^  int write(StringPiece buf) { return ::gzwrite(file_, buf.data(), buf.size()); }$/;"	f	class:muduo::GzipFile
write	SocketsOps.cc	/^ssize_t sockets::write(int sockfd, const void *buf, size_t count)$/;"	f	class:sockets
write	ZlibStream.h	/^  bool write(Buffer* input)$/;"	f	class:muduo::net::ZlibOutputStream
write	ZlibStream.h	/^  bool write(StringPiece buf)$/;"	f	class:muduo::net::ZlibOutputStream
writeCallback_	Channel.h	/^				EventCallback writeCallback_;$/;"	m	class:muduo::net::Channel
writeCompleteCallback_	TcpClient.h	/^				WriteCompleteCallback writeCompleteCallback_;$/;"	m	class:muduo::net::TcpClient
writeCompleteCallback_	TcpConnection.h	/^				WriteCompleteCallback writeCompleteCallback_;$/;"	m	class:muduo::net::TcpConnection
writeCompleteCallback_	TcpServer.h	/^				WriteCompleteCallback writeCompleteCallback_;$/;"	m	class:muduo::net::TcpServer
writerIndex_	Buffer.h	/^				size_t writerIndex_;$/;"	m	class:muduo::net::Buffer
writtenBytes	FileUtil.h	/^  off_t writtenBytes() const { return writtenBytes_; }$/;"	f	class:muduo::FileUtil::AppendFile
writtenBytes_	FileUtil.h	/^  off_t writtenBytes_;$/;"	m	class:muduo::FileUtil::AppendFile
year	Date.h	/^    int year; \/\/ [1900..2500]$/;"	m	struct:muduo::Date::YearMonthDay
year	Date.h	/^  int year() const$/;"	f	class:muduo::Date
yearMonthDay	Date.cc	/^Date::YearMonthDay Date::yearMonthDay() const$/;"	f	class:Date
zero	LogStream.cc	/^		const char* zero = digits + 9;$/;"	m	namespace:muduo::detail
zerror_	ZlibStream.h	/^  int zerror_;$/;"	m	class:muduo::net::ZlibInputStream
zerror_	ZlibStream.h	/^  int zerror_;$/;"	m	class:muduo::net::ZlibOutputStream
zlibErrorCode	ZlibStream.h	/^  int zlibErrorCode() const { return zerror_; }$/;"	f	class:muduo::net::ZlibOutputStream
zlibErrorMessage	ZlibStream.h	/^  const char* zlibErrorMessage() const { return zstream_.msg; }$/;"	f	class:muduo::net::ZlibOutputStream
zstream_	ZlibStream.h	/^  z_stream zstream_;$/;"	m	class:muduo::net::ZlibInputStream
zstream_	ZlibStream.h	/^  z_stream zstream_;$/;"	m	class:muduo::net::ZlibOutputStream
~Acceptor	Acceptor.cc	/^Acceptor::~Acceptor()$/;"	f	class:Acceptor
~AppendFile	FileUtil.cc	/^FileUtil::AppendFile::~AppendFile()$/;"	f	class:FileUtil::AppendFile
~AsyncLogging	AsyncLogging.h	/^  ~AsyncLogging()$/;"	f	class:muduo::AsyncLogging
~Channel	Channel.cc	/^Channel::~Channel()$/;"	f	class:Channel
~Condition	Condition.h	/^  ~Condition()$/;"	f	class:muduo::Condition
~Connector	Connector.cc	/^Connector::~Connector()$/;"	f	class:Connector
~Deleter	ThreadLocalSingleton.h	/^    ~Deleter()$/;"	f	class:muduo::ThreadLocalSingleton::Deleter
~EPollPoller	EPollPoller.cc	/^EPollPoller::~EPollPoller()$/;"	f	class:EPollPoller
~EventLoop	EventLoop.cc	/^EventLoop::~EventLoop()$/;"	f	class:EventLoop
~EventLoopThread	EventLoopThread.cc	/^EventLoopThread::~EventLoopThread()$/;"	f	class:EventLoopThread
~EventLoopThreadPool	EventLoopThreadPool.cc	/^EventLoopThreadPool::~EventLoopThreadPool()$/;"	f	class:EventLoopThreadPool
~File	TimeZone.cc	/^  ~File()$/;"	f	class:muduo::detail::File
~FixedBuffer	LogStream.h	/^				~FixedBuffer()$/;"	f	class:muduo::detail::FixedBuffer
~GzipFile	GzipFile.h	/^  ~GzipFile()$/;"	f	class:muduo::GzipFile
~Logger	Logging.cc	/^Logger::~Logger()$/;"	f	class:Logger
~ReadSmallFile	FileUtil.cc	/^FileUtil::ReadSmallFile::~ReadSmallFile()$/;"	f	class:FileUtil::ReadSmallFile
~Socket	Socket.cc	/^Socket::~Socket()$/;"	f	class:Socket
~TcpClient	TcpClient.cc	/^TcpClient::~TcpClient()$/;"	f	class:TcpClient
~TcpConnection	TcpConnection.cc	/^TcpConnection::~TcpConnection()$/;"	f	class:TcpConnection
~TcpServer	TcpServer.cc	/^TcpServer::~TcpServer()$/;"	f	class:TcpServer
~Thread	Thread.cc	/^	Thread::~Thread()$/;"	f	class:muduo::Thread
~ThreadLocal	ThreadLocal.h	/^  ~ThreadLocal()$/;"	f	class:muduo::ThreadLocal
~ThreadPool	ThreadPool.cc	/^ThreadPool::~ThreadPool()$/;"	f	class:ThreadPool
~TimerQueue	TimerQueue.cc	/^TimerQueue::~TimerQueue()$/;"	f	class:TimerQueue
~ZlibInputStream	ZlibStream.h	/^  ~ZlibInputStream()$/;"	f	class:muduo::net::ZlibInputStream
~ZlibOutputStream	ZlibStream.h	/^  ~ZlibOutputStream()$/;"	f	class:muduo::net::ZlibOutputStream
